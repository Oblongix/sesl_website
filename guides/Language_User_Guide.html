<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SESL Language Reference & Engine Architecture</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Complete SESL Language Specification and Engine Reference. Covers language syntax, model structure, rules, facts, engine architecture, configuration, validation, and business examples." />
  <link rel="icon" type="image/x-icon" href="../assets/SESLIcon.ico" />

  <!-- Load dark mode before rendering -->
  <script>
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme === "dark" || (!savedTheme && window.matchMedia("(prefers-color-scheme: dark)").matches)) {
      document.documentElement.classList.add("dark");
    }
  </script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            brand: { 300: "#a5b4fc", 500: "#6366f1", 600: "#4f46e5" }
          },
          fontFamily: { sans: ["Inter", "system-ui", "Arial"] }
        }
      }
    };
  </script>

  <style>
    pre {
      background-color: #e5e7eb !important;
      border-radius: 0.5rem;
      padding: 1rem;
      overflow-x: auto;
      border: 1px solid #d1d5db;
      margin-top: 8px !important;
      margin-bottom: 8px !important;
    }
    
    .dark pre {
      background-color: #374151 !important;
      border-color: #4b5563;
    }
    
    pre code {
      background-color: transparent !important;
      color: inherit;
    }
  </style>
</head>

<body class="bg-white text-slate-900 dark:bg-slate-950 dark:text-slate-100 antialiased">

<!-- HEADER -->
<header class="border-b border-slate-300 bg-white/80 backdrop-blur sticky top-0 z-40 dark:border-slate-800 dark:bg-slate-950/80">
  <div class="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">

    <!-- LOGO -->
    <a href="../index.html" class="flex items-center gap-3">
      <img src="../assets/SESL Logo.png" class="h-10 block dark:hidden" alt="SESL logo light" />
      <img src="../assets/SESL Logo Dark.png" class="h-10 hidden dark:block" alt="SESL logo dark" />
    </a>

    <!-- DESKTOP NAV -->
    <nav class="hidden md:flex gap-8 text-sm font-medium">
      <a href="../index.html">Home</a>
      <a href="../product.html">Product</a>
      <a href="../solutions.html">Solutions</a>
      <a href="../resources.html" class="text-brand-600 dark:text-brand-300 font-semibold">Resources</a>
      <a href="../about.html">About</a>
    </nav>

    <!-- RIGHT SIDE -->
    <div class="flex items-center gap-4">
      <a href="../login.html"
         class="px-4 py-2 rounded-lg border border-slate-300 text-slate-800 hover:bg-slate-200
                dark:border-slate-700 dark:text-slate-200 dark:hover:bg-slate-800
                text-sm font-medium transition-colors">
        Login
      </a>

      <button id="themeToggle"
        class="p-2 rounded-full border border-slate-300 text-slate-800 hover:bg-slate-200 
               dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800 transition-colors"
        type="button">
        ðŸŒ™
      </button>

      <!-- MOBILE MENU BUTTON -->
      <button id="mobileMenuBtn"
        class="md:hidden p-2 rounded-lg border border-slate-300 dark:border-slate-700 text-xl"
        type="button">
        â˜°
      </button>
    </div>

  </div>
</header>

<!-- MOBILE MENU -->
<div id="mobileMenu"
  class="hidden md:hidden flex-col bg-white dark:bg-slate-900 border-b border-slate-300 dark:border-slate-800 px-4 py-4 space-y-3 text-sm font-medium">

  <a href="../index.html" class="block">Home</a>
  <a href="../product.html" class="block">Product</a>
  <a href="../solutions.html" class="block">Solutions</a>
  <a href="../resources.html" class="block text-brand-600 dark:text-brand-300">Resources</a>
  <a href="../about.html" class="block">About</a>

</div>

<!-- HERO -->
<section class="pt-24 pb-10 px-4 text-center">
  <div class="max-w-3xl mx-auto">
    <h1 class="text-4xl sm:text-5xl font-semibold mb-6">SESL Language Reference & Engine Architecture</h1>
    <p class="text-lg text-slate-700 dark:text-slate-300">
      The comprehensive guide to the SESL language specification, engine implementation, and rule evaluation model.
      Learn the syntax, structure, and internal architecture that powers deterministic, explainable decision logic.
    </p>
  </div>
</section>

<!-- MAIN CONTENT -->
<main class="pb-24 px-4 border-t border-slate-200 dark:border-slate-800">
  <div class="max-w-7xl mx-auto grid gap-10 lg:grid-cols-[280px,1fr]">

    <!-- TABLE OF CONTENTS -->
    <aside class="lg:sticky lg:top-24 self-start">
      <div class="p-5 rounded-2xl bg-slate-50 dark:bg-slate-900/40 border border-slate-200 dark:border-slate-800">
        <h2 class="text-sm font-semibold tracking-wide text-slate-500 dark:text-slate-400 mb-3 uppercase">
          Table of contents
        </h2>
        <nav class="space-y-2 text-sm">
          <a href="#introduction" class="block hover:text-brand-600">1. Introduction to SESL</a>
          <a href="#usage" class="block hover:text-brand-600">2. What SESL is used for</a>
          <a href="#installation" class="block hover:text-brand-600">3. Installation</a>
          <a href="#quick-start" class="block hover:text-brand-600">4. Quick start</a>
          <a href="#model-structure" class="block hover:text-brand-600">5. Structure of a SESL model</a>
          <a href="#rules-structure" class="block hover:text-brand-600">6. Rules structure</a>
          <a href="#rule-statements" class="block hover:text-brand-600">7. Rule statements and syntax</a>
          <a href="#expressions" class="block hover:text-brand-600">8. Expressions and functions</a>
          <a href="#facts-structure" class="block hover:text-brand-600">9. Facts structure</a>
          <a href="#config" class="block hover:text-brand-600">10. Engine configuration</a>
          <a href="#validation" class="block hover:text-brand-600">11. Validation and linting</a>
          <a href="#engine" class="block hover:text-brand-600">12. How the engine works</a>
          <a href="#output" class="block hover:text-brand-600">13. Output and explanation</a>
          <a href="#truth-maintenance" class="block hover:text-brand-600">14. Truth maintenance</a>
          <a href="#examples" class="block hover:text-brand-600">15. Business examples</a>
          <a href="#best-practices" class="block hover:text-brand-600">16. Best practices</a>
          <a href="#conclusion" class="block hover:text-brand-600">17. Conclusion and next steps</a>
        </nav>
      </div>
    </aside>

    <!-- GUIDE BODY -->
    <article class="prose prose-slate dark:prose-invert max-w-none">
      <!-- INTRODUCTION -->
      <section id="introduction" class="scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">1. Introduction to SESL</h2>
        <p>
          SESL (Simple Expert System Language) is a deterministic, structured rule language designed for expressing decision logic
          in a form that is both human-readable and machine-executable. Unlike probabilistic systems or general-purpose programming
          languages, SESL is intentionally focused: it allows you to represent business rules, policies, and decision workflows as
          clear, declarative statements that the SESL engine evaluates using forward-chaining inference.
        </p>
        <p>
          A SESL model is a single YAML-based text document that contains rules, example scenarios (facts), and optional constants.
          The engine reads this model and applies the rules to input data to produce deterministic outcomes with complete explainability.
          Every decision is backed by a detailed trace showing exactly which rules fired, in what order, and why each conclusion was reached.
        </p>

        <h3 class="text-2xl font-semibold mt-8 mb-3">1.1 Purpose and design philosophy</h3>
        <p>
          The core purpose of SESL is to separate your business decision logic from your application code while maintaining complete transparency, 
          traceability, and the ability to change rules without complex deployments. Instead of embedding decision logic deep inside application code, 
          SESL lets you express it as clear, structured rules that can be understood, reviewed, and modified by business stakeholders as easily as 
          by software engineers.
        </p>

        <p>
          SESL embraces four fundamental design principles that shape everything about how the engine works and how you write rules.
        </p>

        <p class="mb-2">
          The first principle is Determinism. This means that whenever you run the engine with the same input data, it will always produce exactly 
          the same output. There is no randomness, no probabilistic guessing, and no hallucination. You know what the engine will do because you 
          wrote the rules and you can see exactly how they execute. This is critical for compliance, auditing, and for systems where consistency 
          and reproducibility matter more than anything else.
        </p>

        <p class="mb-2">
          The second principle is Explainability. Every decision made by SESL is backed by a complete trace showing exactly which rules fired, 
          in what order, and why each conclusion was reached. This enables auditing, regulatory compliance verification, and most importantly, 
          gives your users confidence that decisions are fair, transparent, and based on documented rules they can understand and challenge.
        </p>

        <p class="mb-2">
          The third principle is Readability. Rules are expressed in a simple, structured text format that can be read and discussed by both 
          non-technical business stakeholders and software engineers. You do not need to learn a programming language to understand what a SESL 
          rule does. Business analysts can read a rule and understand it. Regulators can read it and verify compliance. This makes rules documents 
          and rules review much more practical.
        </p>

        <p>
          The fourth principle is Maintainability. Business logic can be added, removed, and reordered without changing the engine itself. When 
          you need to update a rule or add a new decision path, you edit the model file. Changes are localized to one place, reducing the risk 
          of unintended side effects that often come from large code changes. You can version control your rules the same way you version control 
          your code, and rules changes do not require full application deployments.
        </p>

        <h3 class="text-2xl font-semibold mt-8 mb-3">1.2 Main use cases</h3>
        <p>
          SESL works particularly well for scenarios where decision logic needs to be understood, audited, and changed frequently. 
          Here are the situations where SESL makes the most sense.
        </p>

        <p class="mb-2">
          If non-technical users need to understand or review the rules that drive decisions, SESL is ideal. Because the language 
          is readable and structured, business analysts and subject matter experts can review rules without needing technical support.
        </p>

        <p class="mb-2">
          When decisions must be explained to regulators, auditors, customers, or internal review teams, SESL provides complete 
          traceability. You can show exactly which rules were evaluated and why a particular decision was made. This is essential 
          in regulated industries like banking, insurance, and healthcare.
        </p>

        <p class="mb-2">
          If your decision logic changes frequently and you need to edit rules without large code deployments, SESL eliminates 
          the coupling between business logic and application code. Rules can be updated independently, tested, and deployed without 
          requiring application restarts or code reviews.
        </p>

        <p class="mb-2">
          When compliance and reproducibility are critical requirements, SESL ensures that the same input always produces the same 
          output. There is no guessing about what the system will do in a particular situation. This certainty is invaluable for 
          compliance audits and regulatory demonstrations.
        </p>

        <p>
          Finally, when multiple teams need to collaborate on rule definitions without code-level integration risks, SESL provides 
          a neutral format that business teams, compliance teams, and engineering teams can all work with. Rules become a shared 
          artifact that belongs to the organization rather than the engineering team.
        </p>

        <h3 class="text-2xl font-semibold mt-8 mb-3">1.3 Typical SESL applications</h3>
        <p>
          Across many industries, organizations use SESL to make decisions that matter. Here are the most common applications.
        </p>

        <p class="mb-2">
          In Eligibility and Underwriting, SESL helps determine whether customers qualify for loans, insurance products, or benefits. 
          When a customer applies for a loan, SESL can evaluate their income, credit history, employment status, and other factors to 
          decide whether they are eligible and what terms apply. Insurance underwriting uses similar logic to decide which policies can 
          be issued and at what premium rates.
        </p>

        <p class="mb-2">
          In Risk Assessment and Scoring, SESL evaluates multiple factors to produce a risk score or risk band. A bank might use SESL 
          to score the credit risk of a loan applicant. An insurance company might score the operational risk of a new business partnership. 
          An investment firm might score the compliance risk of a transaction. These risk scores then drive business decisions about approval, 
          pricing, or enhanced review.
        </p>

        <p class="mb-2">
          In Pricing and Discounting, SESL applies volume discounts, dynamic pricing rules, and premium calculations based on customer 
          characteristics and purchase patterns. An e-commerce company might use SESL to determine discounts based on customer tier and 
          purchase quantity. An insurance company might use SESL to calculate premiums based on risk factors.
        </p>

        <p class="mb-2">
          In Compliance and Policy Enforcement, SESL ensures that transactions and processes comply with regulatory requirements and 
          internal policies. Banks use SESL for sanctions screening and regulatory compliance checks. Government agencies use SESL to 
          apply policy rules consistently across all constituents. Healthcare providers use SESL to enforce clinical guidelines and billing rules.
        </p>

        <p class="mb-2">
          In Operational Automation, SESL makes routing decisions, prioritization decisions, and workflow selection decisions. A customer 
          service system might use SESL to route inquiries to the right department based on the nature of the inquiry. A logistics company 
          might use SESL to decide which warehouse should fulfill an order based on location and inventory.
        </p>

        <p>
          In Fraud Detection, SESL identifies suspicious transactions and patterns with clear evidence trails. A payment processor might 
          use SESL to flag transactions that meet suspicious criteria like unusually large amounts, unusual timing, or unusual geography. 
          Because every flag is backed by which rules matched, investigation teams can understand exactly why something was flagged.
        </p>

        <h3 class="text-2xl font-semibold mt-8 mb-3">1.4 Comparison with alternative approaches</h3>
        <p>
          When you face a decision problem, you have several options for how to solve it. SESL compares favorably to each alternative 
          in different ways, depending on what matters most to your organization.
        </p>

        <p class="mb-2">
          Compared to hard-coded decision logic embedded directly in your application, SESL provides several advantages. When business 
          logic is hard-coded, changing it requires code review, testing, and deployment of new application binaries. This coupling 
          between business logic and application code makes changes slow and risky. SESL rules are declarative and separate from your 
          application. A rule change does not require code review or application deployment. Business teams can propose rule changes, 
          review them with domain experts, and deploy them independently. This separation of concerns dramatically reduces the friction 
          and risk of rule updates.
        </p>

        <p class="mb-2">
          Compared to general-purpose rules engines that attempt to be comprehensive, SESL is intentionally small and focused. Large 
          rules engines often support complex features like nested rule sets, stateful queries, and full Turing-completeness. This power 
          comes at the cost of complexity. SESL intentionally does not attempt to be Turing-complete. This deliberate simplicity makes 
          the engine easier to understand, easier to audit for safety and correctness, and easier to explain to stakeholders. You can 
          reason about what SESL will do because it is fundamentally simpler than a general-purpose engine.
        </p>

        <p class="mb-2">
          Compared to machine learning models, SESL is fundamentally different in philosophy. Machine learning models learn patterns 
          from data and generate probabilistic outputs. The same input may produce different outputs depending on probabilistic weights 
          or random seeds. SESL is deterministic and fully explainable. The same input always produces the same output. SESL is ideal 
          for situations where reproducibility and explainability are non-negotiable requirements. Machine learning excels when you have 
          lots of historical data and you want to discover patterns. SESL excels when you have documented decision rules and you want to 
          apply them consistently and transparently.
        </p>

        <p>
          Compared to spreadsheets, which many organizations use to manage complex logic, SESL provides structure, type safety, and 
          version control. Spreadsheets are flexible and accessible, but they often become unmaintainable as they grow. Hidden dependencies, 
          circular references, and untracked changes become common. SESL enforces structure through its syntax. It supports dependency analysis 
          to catch problems before they happen in production. Rules can be version controlled in your standard version control system, with 
          full change history and audit trails. For complex decision logic that multiple people need to maintain, SESL is much more maintainable 
          than spreadsheets.
        </p>

        <h3 class="text-2xl font-semibold mt-8 mb-3">1.5 Structure of this guide</h3>
        <p>
          This comprehensive reference guide is designed to take you from understanding what SESL is all the way through to writing, 
          validating, deploying, and maintaining SESL models in production. The guide is organized into 17 major sections, each building 
          on the previous ones.
        </p>

        <p class="mb-2">
          If you are completely new to SESL, start with Sections 1 through 5. Section 1 is this introduction, which gives you the conceptual 
          foundation. Section 2 explains what SESL is used for and how it fits into your architecture. Section 3 covers installation so you 
          have the engine running. Section 4 is a quick start that walks you through creating your first tiny model and running it. Section 5 
          explains the overall structure of a SESL model so you understand the big picture before diving into details.
        </p>

        <p class="mb-2">
          Once you understand the basics, Sections 6 through 9 provide a complete reference for the SESL language itself. Section 6 explains 
          how to structure rules and what fields each rule can contain. Section 7 covers the complete syntax for conditions and actions. 
          Section 8 is a comprehensive reference for expressions, operators, and built-in functions. Section 9 explains how to structure 
          your input data (facts) and how the engine uses them.
        </p>

        <p class="mb-2">
          Sections 10 through 14 dive into the engine itself and advanced features. Section 10 explains all the configuration options that 
          control how strictly the engine checks your code and handles edge cases. Section 11 covers validation and linting, which help you 
          catch mistakes early. Section 12 explains how the engine works internally: how it loads models, orders rules, and executes them. 
          Section 13 explains the output the engine produces and how to interpret it. Section 14 covers truth maintenance, which enables 
          you to explain exactly why a particular value was produced.
        </p>

        <p>
          Finally, Sections 15 through 17 provide practical guidance. Section 15 includes five realistic business examples showing SESL 
          solving actual decision problems in finance, retail, logistics, and compliance. Section 16 covers best practices for organizing 
          your models, naming conventions, and common pitfalls to avoid. Section 17 wraps up with next steps and guidance on how to continue 
          learning and building with SESL.
        </p>

        <p class="mt-6">
          Throughout this guide, code examples use YAML syntax, which is the standard format for SESL models. When showing how to use SESL 
          from code, we use Python, which is the language in which SESL is implemented. Even if you primarily use SESL from a different 
          language, the Python examples show the same concepts that apply in any language.
        </p>
      </section>

      <!-- USAGE -->
      <section id="usage" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">2. What SESL is used for</h2>
        <p>
          SESL is designed for decision problems where you need to apply a set of rules to structured input data and produce 
          decisions or scores. The typical pattern is that your rules read input facts, evaluate conditions, and write conclusions 
          to result fields. If this pattern matches your problem, SESL is likely a good fit.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">2.1 Types of problems SESL solves well</h3>
        <p>
          SESL is well-suited for several broad categories of decision problems. Understanding which category your problem falls into 
          helps you understand whether SESL is the right choice.
        </p>

        <p class="mb-2">
          Binary decisions are situations where there are only two possible outcomes, such as approve or decline, pass or fail, or flag 
          or clear. A loan application is approved or declined. A compliance check passes or fails. A transaction is flagged for review 
          or cleared. Many business processes boil down to binary decisions, and SESL handles these elegantly.
        </p>

        <p class="mb-2">
          Multi-level classifications are situations where there are multiple possible outcomes organized into categories or bands. Instead 
          of just approve or decline, you might have approve, refer, or decline. Instead of safe or risky, you might have low risk, medium 
          risk, or high risk. SESL can apply rules to populate these classifications based on input conditions.
        </p>

        <p class="mb-2">
          Numeric calculations that depend on conditions are situations where the output value depends on the values of the inputs. You 
          might apply a 10 percent discount to large orders, a 15 percent discount to very large orders, and an additional loyalty discount 
          on top. SESL rules can compute these tiered calculations based on conditions.
        </p>

        <p>
          Aggregation of signals into a single score or recommendation are situations where multiple factors contribute to a final score. 
          A credit score might aggregate income, debt level, payment history, and employment stability. A risk score might aggregate multiple 
          risk factors. SESL makes it easy to express how these component factors combine into a final output.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">2.2 How SESL fits into your overall architecture</h3>
        <p>
          SESL is not designed to be your entire application. Instead, it is a decision component that sits alongside your existing application 
          services. Understanding how SESL fits into your architecture helps you design the interface between SESL and your code.
        </p>

        <p>
          The typical workflow is straightforward. First, your application gathers input data from users, databases, or external services 
          and organizes it into a structured facts structure. Think of facts as the input to the SESL engine. Second, your application loads 
          a SESL model from a model file, a database, or a configuration service. The model contains the rules that will be evaluated. Third, 
          your application calls the SESL engine, passing in the facts and the model. The engine evaluates all the rules against the facts. 
          Fourth, the engine returns the updated facts, which now include result fields with the decisions, scores, and explanations. Finally, 
          your application takes those results and uses them to drive your user experience or downstream actions. You might show the decision 
          to the user, send it to another system, store it in a database, or trigger automated workflows based on it.
        </p>

        <p>
          This architecture means that your application code does not need to contain any decision logic. All of that logic lives in the SESL 
          model, which business teams can understand and modify. Your application code simply prepares input data, calls the engine, and 
          processes output results.
        </p>
      </section>

      <!-- INSTALLATION -->
      <section id="installation" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">3. Installation instructions</h2>

        <p>
          Getting SESL installed on your system is straightforward and quick. SESL is distributed as a single downloadable zip file that contains 
          the SESL executable and example files. You can be up and running in just a few minutes. This section walks you through the installation 
          process, testing your installation, and managing upgrades and removals.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.1 Prerequisites</h3>
        <p>
          Before you download and install SESL, make sure you have the basic prerequisites in place. The good news is that SESL has minimal 
          requirements.
        </p>

        <p class="mb-2">
          You need a computer running Windows, macOS, or Linux with enough disk space to store the SESL executable and your model files. Most 
          machines have plenty of space; a few hundred megabytes is sufficient.
        </p>

        <p class="mb-2">
          You need internet access to download the zip file from https://www.sesl.ai. You also need to be able to unzip files on your computer. 
          Most operating systems have built-in tools for this (right-click on a zip file and select "Extract" on Windows, or double-click on 
          macOS, or use the unzip command on Linux).
        </p>

        <p class="mb-2">
          For local development and learning, you need a text editor to write model files. Any editor worksâ€”Visual Studio Code, Sublime Text, 
          Notepad, vim, or whatever you prefer. No special IDE is required.
        </p>

        <p>
          For production use, you may want a version control system like Git to manage your model files, and you may want to set up automated 
          testing or deployment pipelines to manage model updates safely.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.2 Downloading SESL</h3>
        <p>
          SESL is distributed as a single zip file available from https://www.sesl.ai. Downloading and installing SESL is as simple as 
          downloading a file.
        </p>

        <p class="mb-2">
          Follow these steps:
        </p>

        <ol class="mb-3">
          <li>Visit https://www.sesl.ai in your web browser.</li>
          <li>Look for the download link for SESL. This will typically say something like "Download SESL" or "Get SESL."</li>
          <li>Click the download link. Your browser will download a zip file to your Downloads folder (or your default download location).</li>
          <li>Navigate to the location where the zip file was downloaded.</li>
          <li>Unzip the file. On Windows, right-click and select "Extract All." On macOS, double-click the file. On Linux, use the command <code>unzip sesl-*.zip</code>.</li>
          <li>A directory will be created containing the SESL executable and example files. Remember this locationâ€”you will need it to run SESL.</li>
        </ol>

        <p>
          That's it! You have successfully installed SESL. Unlike software that requires a complex installer, SESL simply lives in the directory 
          you extracted it to. There is no registration, no system-wide installation, and no hidden configuration files to worry about.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.3 Testing your installation</h3>
        <p>
          After installation, you should verify that SESL is working correctly. SESL provides two simple ways to test your installation.
        </p>

        <p class="mb-2">
          The easiest way is to start SESL in online session mode. Navigate to the directory where you extracted SESL and run the SESL executable. 
          On most systems, you can simply run:
        </p>

        <pre><code>./sesl</code></pre>

        <p class="mb-2">
          (On Windows, use <code>sesl.exe</code> instead.) This will start SESL in interactive mode, where you can explore the interface and verify 
          that everything is working. When you run SESL this way, you will also see information about the time remaining on your binary. SESL 
          binaries are time-limited (typically valid for a certain number of days), and you can see how many days are available by checking the 
          information displayed when SESL starts in online mode.
        </p>

        <p class="mb-2">
          Alternatively, you can test SESL in batch mode using a command-line option. This approach is useful for automated testing or for running 
          SESL in a script. Run a command like:
        </p>

        <pre><code>./sesl --batch my_model.sesl.yaml</code></pre>

        <p>
          This will load your model file and run it in batch mode, printing results to the console. If both of these methods work without errors, 
          your SESL installation is ready to use.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.4 Upgrading SESL</h3>
        <p>
          When a new version of SESL is released with bug fixes or new features, upgrading is simple. Since SESL is a standalone zip file with 
          no complex installation, you simply download the new version and replace the old directory.
        </p>

        <p class="mb-2">
          To upgrade to a new version:
        </p>

        <ol class="mb-3">
          <li>Back up your model files and any important data (just to be safe).</li>
          <li>Download the new SESL zip file from https://www.sesl.ai, following the same process as the initial installation.</li>
          <li>Extract the new zip file to a new directory (or replace the old directory if you are sure you have backed up your data).</li>
          <li>Update any scripts or configuration that might reference the old SESL directory location.</li>
          <li>Test the new version using the same testing steps described in section 3.3.</li>
        </ol>

        <p>
          Your model files will work with the new versionâ€”SESL maintains backward compatibility across updates, so you do not need to modify 
          your models when upgrading.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.5 Uninstalling SESL</h3>
        <p>
          If you need to remove SESL from your system for any reason, the process is simple since SESL is self-contained in a single directory.
        </p>

        <p class="mb-2">
          To uninstall SESL:
        </p>

        <ol class="mb-3">
          <li>Make sure you have copied any model files or important data from the SESL directory to another location (if you want to keep them).</li>
          <li>Simply delete the SESL directory. On Windows, right-click and select "Delete." On macOS or Linux, use the command <code>rm -rf sesl-directory-name</code>.</li>
          <li>That's it! SESL is completely removed from your system. There are no lingering files, registry entries, or configuration to clean up.</li>
        </ol>

        <p>
          Unlike complex software installations, SESL leaves no traces on your system when you remove it. This makes it easy to try SESL risk-free 
          or to maintain multiple versions for testing purposes.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.6 Understanding SESL binary time limits</h3>
        <p>
          Each SESL binary is time-limited, meaning it has an expiration date after which it will no longer work. This is a normal part of SESL's 
          licensing model. When you download a version of SESL, it is valid for a certain number of days from the release date (typically 30, 60, 
          or 90 days depending on your license).
        </p>

        <p class="mb-2">
          You can see how many days your SESL binary has remaining by starting SESL in online mode and checking the information displayed. It will 
          tell you something like "This SESL binary expires in 45 days" or "This SESL binary is valid for 30 days from the release date."
        </p>

        <p>
          When your SESL binary expires, you simply download a new version from https://www.sesl.ai to get a fresh binary with more days available. 
          This update model keeps your SESL installation current and ensures you are always using a supported version. Upgrading is simple and 
          painlessâ€”just download, extract, and go.
        </p>
      </section>

      <!-- QUICK START -->
      <section id="quick-start" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">4. Quick start guide</h2>
        <p>
          This quick start section walks you through a complete, concrete example from beginning to end. We will create a tiny SESL model, 
          load it, run the engine, and see the results. The goal is not to cover all possible features or all the edge cases, but to give 
          you a practical sense of what working with SESL feels like and how the pieces fit together.
        </p>

        <p>
          If you are following along, make sure you have SESL installed (see Section 3). You will need a text editor and a Python interpreter. 
          Plan to spend about 10 minutes working through this example.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">4.1 Create a minimal model file</h3>
        <p>
          Start by creating a new text file on your computer called <code>loan-example.sesl.yaml</code>. Open this file in your text editor 
          and paste the following content into it. This tiny model contains everything needed for a working SESL model: a name, some constants, 
          a couple of rules, and an example scenario to test against.
        </p>
        <pre><code>model: "Loan eligibility example"

meta:
  author: "Example author"
  created: "2025-01-01"
  source: "Internal demo"

const:
  minimum_income: 25000
  high_income: 60000

rules:
  - rule: "Set high income flag"
    if: "applicant.income &gt;= const.minimum_income"
    then:
      result.high_income: true
    reason: "Applicant meets the minimum income threshold"

  - rule: "Recommend approval for very high income"
    priority: 10
    if: "applicant.income &gt;= const.high_income"
    then:
      result.decision: "approve"
      result.decision_reason: "Very high income"
    reason: "Applicant has very high income"

facts:
  - name: "Applicant A"
    applicant:
      income: 65000
    result: {}</code></pre>

        <p>This model contains two rules and one fact scenario:</p>
        <ul>
          <li>The first rule sets a flag when the income meets the minimum.</li>
          <li>The second rule decides to approve the loan for very high income.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">4.2 Running the model using SESL online</h3>
        <p>
          SESL provides an interactive online mode that lets you load and test models right from your terminal or command prompt. 
          This is the quickest way to explore a model and see what the rules produce. You interact with SESL through a command-line 
          interface that guides you through loading your model and running the scenarios you have defined.
        </p>

        <p class="mb-2">
          To start SESL in interactive mode, navigate to the directory where you extracted SESL and where your model file is located. 
          Then simply run the SESL executable with no arguments:
        </p>

        <pre><code>./sesl</code></pre>

        <p>
          (On Windows, use <code>sesl.exe</code> instead of <code>./sesl</code>.)
        </p>

        <p class="mb-2">
          When you run this command, SESL will start and display information about itself, including how many days the binary is valid for. 
          The interactive interface will then ask you to load a model. You will be prompted to provide the path to your model file. 
          Type the name of your model file:
        </p>

        <pre><code>Load model:  loan-example.sesl.yaml</code></pre>

        <p class="mb-2">
          SESL will parse your model and show you the available scenarios defined in the facts section. It will then ask you which scenario 
          you want to run. Select a scenario by its number or name, and SESL will execute the rules against the scenario's facts, displaying 
          the results and explanations on screen.
        </p>

        <p>
          This interactive mode is excellent for development, debugging, and understanding how your rules work. You can quickly load different 
          models and test scenarios without writing any code. When you are ready to move to testing or production, you can use the batch mode 
          or Python API described below.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">4.3 Running the model using --batch mode</h3>
        <p>
          When you need to run SESL non-interactivelyâ€”for example, as part of an automated workflow, a build pipeline, or a scheduled taskâ€”you 
          can use batch mode. Batch mode loads your model, runs all the defined scenarios, and outputs the results to the console without 
          requiring any interactive input.
        </p>

        <p class="mb-2">
          To run your model in batch mode, use the <code>--batch</code> flag and provide the path to your model file:
        </p>

        <pre><code>./sesl --batch loan-example.sesl.yaml</code></pre>

        <p class="mb-2">
          SESL will load the model, execute all the scenarios defined in the facts section, and print the results to the console. 
          Each scenario will be processed in order, and you will see the output for each one. This mode is perfect for integration into 
          scripts, continuous integration systems, or any situation where you need automated, unattended execution.
        </p>

        <p>
          Batch mode is particularly useful when you are testing a collection of models or scenarios, or when you want to capture the output 
          for logging or analysis. The results are printed in a structured format that you can parse programmatically if needed.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">4.4 Running the model through Python</h3>
        <p>
          Now that you have a model file, let's write a simple Python script to load it, run the engine, and see the results. 
          The SESL engine exposes two main functions that you will use frequently.
        </p>

        <p class="mb-2">
          The first function is <code>load_model_from_yaml(text)</code>. This function takes the text content of a model file and 
          parses it into compiled rules and example scenarios. Think of this as translating the human-readable model into a form 
          the engine can execute.
        </p>

        <p class="mb-2">
          The second function is <code>forward_chain(rules, facts, monitor, ...)</code>. This is the actual inference engine. 
          You pass in the compiled rules, the facts (input data), and optionally a monitor object for explainability. The engine 
          evaluates the rules and returns the updated facts with results and explanations.
        </p>

        <p>
          Here is a simple runner script that demonstrates how to use these functions. Create a new Python file called <code>run_example.py</code> 
          in the same directory as your model file, and paste this code:
        </p>

        <pre><code>import pathlib
from sesl_engine import load_model_from_yaml, forward_chain, Monitor

# Load model text from the file we created
model_path = pathlib.Path("loan-example.sesl.yaml")
text = model_path.read_text(encoding="utf-8")

# Parse the model into rules and named scenarios
rules, scenarios = load_model_from_yaml(text)

# Take the first scenario to test with
scenario_name, facts = scenarios[0]

# Create a monitor object to capture explanations
monitor = Monitor(theme="colour")

# Run the inference engine
forward_chain(rules, facts, monitor=monitor)

# Print out the results
print("Scenario:", scenario_name)
print("Result:", facts.get("result"))
</code></pre>

        <h3 class="text-2xl font-semibold mt-6 mb-3">4.5 Understanding the output</h3>
        <p>
          When you run the script above, the engine produces several important pieces of information. Understanding what each 
          piece means will help you trust the results and debug any issues that arise.
        </p>

        <p>
          Here is a sample output that you might see when running the loan approval example:
        </p>
        <pre><code>Scenario: Applicant A
Result: {
  'high_income': True,
  'decision': 'approve',
  'decision_reason': 'Very high income',
  'monitor': [...],
  'monitor_blocks': [...],
  'monitor_theme': 'colour'
}</code></pre>

        <p class="mb-2">
          <strong>The Result Field:</strong> This is what your application will actually use. It contains the output of your rules. 
          In our loan example, the result field tells you whether the loan was approved or denied. Each key in the result object 
          represents a fact that was computed during rule evaluation. In this case, <code>high_income</code> was set to True by the 
          first rule, and <code>decision</code> was set to 'approve' by the second rule. The result is deterministic, meaning the 
          same input facts will always produce the same result.
        </p>

        <p class="mb-2">
          <strong>The Decision Reason:</strong> Notice the <code>decision_reason</code> field. This is an example of a derived fact 
          that the rules created. Rules don't just compute decisions; they can also compute explanations. This makes your application 
          more useful because you can show users not just what was decided, but why.
        </p>

        <p class="mb-2">
          <strong>The Monitor Object:</strong> If you created a monitor object like in the example above, the result includes 
          <code>monitor</code> and <code>monitor_blocks</code> fields. These contain rich explainability information about how the 
          decision was made. The monitor tracks every rule that fired, every condition that was evaluated, and every fact that was 
          derived. This is invaluable for explaining decisions to users, auditors, or when debugging unexpected results.
        </p>

        <p>
          To understand why a decision was made, you can print the monitor object directly. It contains detailed information about 
          rule execution order, condition evaluation results, and the full dependency chain that led to your final result. This allows 
          you to answer questions like "Why was the loan denied?" with complete accuracy and transparency, showing exactly which rules 
          fired, which conditions were true, and in what order the evaluation happened.
        </p>
      </section>

      <!-- MODEL STRUCTURE -->
      <section id="model-structure" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">5. Structure of a SESL model</h2>
        <p>
          Every SESL model is a structured document that follows a consistent format. This structure makes models easy to read, 
          maintain, and understand. At the top level, a SESL model file contains five main sections, each serving a specific purpose.
        </p>

        <p class="mb-2">
          The <strong>model</strong> section provides the name or identifier of your model. This is a human-readable label that tells 
          anyone reading the file what the model is for. For example, you might have a model named "Loan Approval Engine" or "Fraud Detection Rules".
        </p>

        <p class="mb-2">
          The <strong>meta</strong> section is optional but highly recommended. This is where you store metadata about your model such 
          as the author name, version number, creation date, last modification date, source document reference, and any important usage notes or caveats. Metadata helps teams understand 
          the context and history of a model, making it easier to maintain and update over time. Common metadata fields include: <code>author</code> (who created or owns the model), <code>version</code> (semantic version number for tracking changes), <code>created</code> (creation date), <code>modified</code> (last update date), <code>source</code> (reference to originating document or policy), and <code>considerations</code> (important notes or warnings about usage).
        </p>

        <p class="mb-2">
          The <strong>const</strong> section defines constants that can be referenced throughout your rules. Constants are values that do 
          not change within a single execution of the engine. They are a powerful way to avoid hard-coding numbers and thresholds directly 
          into your rules. For example, you might define a "minimum_credit_score" constant that multiple rules reference.
        </p>

        <p class="mb-2">
          The <strong>rules</strong> section is where the decision logic lives. This section contains a list of rules that the engine 
          will evaluate. Each rule specifies conditions that must be met and actions that should be taken when those conditions are true. 
          Rules are the heart of your SESL model, and we will explore them in detail in the next section.
        </p>

        <p>
          The <strong>facts</strong> section provides example input scenarios for testing and demonstration. These are not just documentation; 
          they are actual test cases that you can run against your model to verify it works correctly. Each fact scenario describes a specific 
          situation and the expected result.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">5.1 Example model with annotations</h3>
        <pre><code># Model name
model: "Customer loyalty scoring"

# Optional descriptive metadata
meta:
  author: "Loyalty team"
  version: "1.2.0"
  created: "2025-02-10"
  modified: "2025-12-08"
  source: "Marketing rules document v3"
  considerations: "Not for credit risk decisions"

# Constants shared by all rules
const:
  gold_threshold: 1000
  silver_threshold: 500

# List of rule objects
rules:
  - rule: "Set gold tier"
    priority: 20
    if: "customer.points &gt;= const.gold_threshold"
    then:
      result.tier: "gold"
    reason: "Customer points are greater than or equal to gold threshold"

  - rule: "Set silver tier"
    priority: 10
    if: "customer.points &gt;= const.silver_threshold"
    then:
      result.tier: "silver"
    reason: "Customer points are greater than or equal to silver threshold"

# Example fact scenarios
facts:
  - name: "Customer with 1200 points"
    customer:
      points: 1200
    result: {}

  - name: "Customer with 700 points"
    customer:
      points: 700
    result: {}</code></pre>

        <p class="mb-3">
          This example shows how all parts work together. Notice how the rules reference the constants defined in the const section using 
          the <code>const.</code> prefix. This allows you to update threshold values in one place rather than searching through all your rules.
        </p>

        <p class="mb-2">
          Each fact scenario contains an initial <code>result</code> mapping, which starts as empty. As the engine evaluates rules, it will 
          populate this result mapping with the decisions and computed values. The facts section acts as your test suite, allowing you to run 
          the same rules against different input scenarios to verify behavior.
        </p>

        <p>
          Notice the priority values on the rules. The "Set gold tier" rule has priority 20, while "Set silver tier" has priority 10. Higher 
          priority rules are evaluated first. This ensures that the most specific rules (like checking for gold tier) run before more general rules 
          (like checking for silver tier), preventing unexpected behavior where a customer might match the silver rule before the gold rule is evaluated.
        </p>
      </section>

      <!-- RULES STRUCTURE -->
      <section id="rules-structure" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">6. Rules structure</h2>
        <p>
          Rules are the core of every SESL model. A rule in SESL is a simple but powerful structure that connects conditions with actions. 
          The idea is straightforward: if certain conditions are satisfied, then execute certain actions. Actions typically write values 
          into the facts structure, allowing rules to communicate results and intermediate values to other rules.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">6.1 Anatomy of a rule</h3>
        <p>
          Every rule in SESL follows a consistent structure. Here is an example of a complete rule with all possible fields:
        </p>
        <pre><code>- rule: "Human readable rule name"
  priority: 10
  if: "customer.age &gt;= 18"
  let:
    age_band: "customer.age &gt;= 65"
  then:
    result.is_adult: true
  reason: "Customer has reached legal adulthood"
  stop: false</code></pre>

        <p class="mb-2">
          The <strong>rule</strong> field is required and provides a human-readable name for the rule. This name appears in explanations and 
          monitoring output, so choose a name that clearly describes what the rule does. For example, "Check if customer is eligible" is much 
          better than "Rule 1".
        </p>

        <p class="mb-2">
          The <strong>priority</strong> field is optional but very useful for controlling execution order. It is an integer where higher values 
          indicate higher priority. The engine evaluates high-priority rules before low-priority rules. This is essential when you have rules 
          that depend on each other or when you want more specific rules to run before more general ones.
        </p>

        <p class="mb-2">
          The <strong>if</strong> field specifies the condition or nested condition structure that must be satisfied for the rule to fire. If 
          the condition evaluates to true, the rule executes. If it evaluates to false, the rule does not execute and its actions are not taken.
        </p>

        <p class="mb-2">
          The <strong>let</strong> field is optional and defines helper variables that are computed before evaluating the rule's actions. 
          This is useful when you have complex expressions that you want to compute once and then use in multiple places. For example, you 
          might compute "is_senior_citizen" once in the let section and then use it in the then section.
        </p>

        <p class="mb-2">
          The <strong>then</strong> field specifies the mapping of target paths to expressions that should be written when the rule fires. 
          In the example above, when the condition is true, the engine writes the value "true" to the path "result.is_adult". The then field 
          is how rules produce output values.
        </p>

        <p class="mb-2">
          The <strong>reason</strong> field is optional but highly recommended. It provides a human-readable explanation of why the rule exists. 
          This explanation is included in the monitor output, helping anyone who reviews the results understand the business logic behind the 
          decision.
        </p>

        <p>
          The <strong>stop</strong> field is optional and defaults to false. When you set stop to true, the engine stops evaluating any remaining 
          rules after this rule fires. This is useful for rules that represent final decisions from which you do not want other rules to deviate.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">6.2 Rule evaluation order</h3>
        <p>
          The order in which the SESL engine evaluates rules is deterministic and intelligent. Understanding this order helps you write rules 
          that work correctly together.
        </p>

        <p class="mb-2">
          First, the engine groups rules by priority. All rules with the highest priority number are evaluated first. Then rules with the next 
          highest priority are evaluated, and so on. This is how you control which rules run before others.
        </p>

        <p class="mb-2">
          Within each priority group, the engine performs data-driven dependency ordering. If one rule writes to a fact that another rule reads, 
          the writing rule is evaluated before the reading rule. For example, if Rule A writes to "result.approved" and Rule B reads from "result.approved", 
          then Rule A will be evaluated before Rule B, regardless of their positions in the file.
        </p>

        <p class="mb-2">
          Within a single priority group when there are no dependencies between rules, the engine preserves the original order from the model file. 
          This means that if two rules have the same priority and neither reads or writes to values the other uses, they will execute in the order 
          they appear in your model file.
        </p>

        <p>
          The engine runs in multiple iterations. It evaluates all rules once, checks if any facts changed, and if they did, it runs all the rules 
          again. This forward chaining behavior continues until either no facts change in an iteration or until the maximum number of iterations is 
          reached. This allows rules to build on values produced by other rules, creating sophisticated decision logic through simple, composable rules.
        </p>
      </section>

      <!-- RULE STATEMENTS -->
      <section id="rule-statements" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">7. Rule statements and full syntax</h2>
        <p>
          SESL supports several kinds of statements that you can use inside rules to build sophisticated decision logic. This section 
          describes each statement type with syntax, examples, and guidance on when to use each one.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.1 Condition expressions</h3>
        <p>
          The simplest form of a condition is a single expression string in the <code>if</code> field. A condition expression compares two 
          values using an operator and returns true or false. When the condition is true, the rule fires and its actions execute.
        </p>

        <p class="mb-2">
          The basic form of a condition expression is:
        </p>
        <pre><code>&lt;left operand&gt; &lt;operator&gt; &lt;right operand&gt;</code></pre>

        <p class="mb-2">
          The left operand is typically a path into your facts, like <code>customer.age</code> or <code>application.income</code>. The operator 
          specifies what kind of comparison to perform. The right operand can be a literal value (like <code>'United Kingdom'</code> or <code>18</code>), 
          another path, or even a constant reference.
        </p>

        <p>SESL supports the following comparison operators:</p>
        <ul class="mb-3">
          <li><code>==</code> checks if two values are equal</li>
          <li><code>!=</code> checks if two values are not equal</li>
          <li><code>&gt;</code> checks if the left value is greater than the right value</li>
          <li><code>&gt;=</code> checks if the left value is greater than or equal to the right value</li>
          <li><code>&lt;</code> checks if the left value is less than the right value</li>
          <li><code>&lt;=</code> checks if the left value is less than or equal to the right value</li>
          <li><code>in</code> checks if the left value is a member of the right container (like a list)</li>
          <li><code>not in</code> checks if the left value is not a member of the right container</li>
        </ul>

        <p>
          Here are some practical examples of condition expressions. You might write <code>"customer.country == 'United Kingdom'"</code> to check 
          if the customer is in a specific country. Or <code>"applicant.income &gt;= 50000"</code> to check if income meets a minimum threshold. 
          Or <code>"applicant.risk_level in ['low', 'medium']"</code> to check if the risk level is in an acceptable set.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.2 Logical condition blocks</h3>
        <p>
          For more complex decision logic, SESL allows you to combine multiple conditions using logical operators. Instead of putting a simple 
          expression string in the <code>if</code> field, you can use a structured mapping with logical keys like <code>all</code>, <code>any</code>, 
          and <code>not</code>.
        </p>

        <p class="mb-2">
          The <code>all</code> key means all conditions must be true for the rule to fire. The <code>any</code> key means at least one condition 
          must be true. The <code>not</code> key negates a condition, making it true when the inner condition is false. These can be nested to 
          create arbitrarily complex logic.
        </p>

        <p>
          Here is an example that shows how to combine conditions with logical operators:
        </p>
        <pre><code>if:
  all:
    - "customer.age &gt;= 18"
    - any:
        - "customer.country == 'United Kingdom'"
        - "customer.country == 'Ireland'"</code></pre>

        <p class="mb-2">
          This condition says: "The customer must be 18 or older AND the customer must be from either the United Kingdom or Ireland." The top-level 
          <code>all</code> means both the age check and the country check must be true. The nested <code>any</code> means the customer can satisfy 
          the country requirement by being from either of the two countries.
        </p>

        <p>
          You can nest these logical blocks as deeply as needed. For example, you might have an <code>all</code> block containing two <code>any</code> 
          blocks, or an <code>any</code> block containing a <code>not</code> block, and so on. This allows you to express complex business logic 
          clearly and readably.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.3 Let statements</h3>
        <p>
          The <code>let</code> section allows you to define intermediate values that you can reference in conditions and actions. Think of let 
          variables as helper values that simplify your rules by avoiding repetition and making logic clearer.
        </p>

        <p class="mb-2">
          Each entry in the <code>let</code> mapping is a variable name paired with an expression. The engine evaluates each expression and stores 
          the result. You can then reference these variables anywhere else in the rule. This is particularly useful when you have a complex expression 
          that you need to use in multiple places.
        </p>

        <p>
          Here is an example:
        </p>
        <pre><code>let:
  income_band: "applicant.income &gt;= 80000"
  total_exposure: "existing_loans + requested_amount"</code></pre>

        <p class="mb-2">
          In this example, <code>income_band</code> will be true if the applicant earns 80,000 or more, and <code>total_exposure</code> will be the 
          sum of existing loans and the requested amount. You can then reference these variables in your conditions or actions. For instance, you 
          might write a condition like <code>"let.income_band == true"</code> or use <code>total_exposure</code> in a calculation.
        </p>

        <p>
          Let variables are computed once when the rule is evaluated and are not persisted in the facts structure unless you explicitly write them 
          to the facts in the <code>then</code> section. This makes them useful for temporary calculations within a single rule.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.4 Actions in the then block</h3>
        <p>
          The <code>then</code> block specifies what happens when a rule fires. It is a mapping from target paths to expressions. When the rule's 
          conditions are satisfied, the engine evaluates each expression and writes the result to the corresponding path in the facts.
        </p>

        <p class="mb-2">
          Here is an example:
        </p>
        <pre><code>then:
  result.decision: "approve"
  result.score: "base_score + bonus"</code></pre>

        <p class="mb-2">
          In this example, when the rule fires, the engine writes the string "approve" to <code>result.decision</code> and evaluates the expression 
          <code>base_score + bonus</code>, writing the result to <code>result.score</code>. Paths are dot-separated sequences like <code>result.decision</code> 
          or <code>customer.flags.high_risk</code>.
        </p>

        <p class="mb-2">
          Paths allow you to organize your output into nested structures. For example, you might have a <code>result</code> object with fields for 
          <code>decision</code>, <code>score</code>, <code>explanation</code>, and <code>confidence</code>. The expressions on the right-hand side can 
          reference facts, constants from the model, and helper variables from the <code>let</code> block.
        </p>

        <p>
          One important detail: in strict path mode, intermediate parts of a path must exist. For example, to write to <code>result.flags.high_risk</code>, 
          the <code>result</code> and <code>result.flags</code> objects must already exist. However, you can enable automatic path creation, which causes 
          the engine to create any missing intermediate structures automatically. This is controlled by the <code>SESL_AUTO_CREATE_PATHS</code> configuration 
          option, which is enabled by default.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.5 Summary table of rule statement fields</h3>
        <div class="overflow-x-auto border border-slate-200 dark:border-slate-800 rounded-xl">
          <table class="min-w-full text-sm">
            <thead class="bg-slate-50 dark:bg-slate-900/40">
              <tr>
                <th class="px-4 py-2 text-left font-semibold">Field</th>
                <th class="px-4 py-2 text-left font-semibold">Purpose</th>
                <th class="px-4 py-2 text-left font-semibold">Key elements</th>
                <th class="px-4 py-2 text-left font-semibold">Notes</th>
              </tr>
            </thead>
            <tbody class="divide-y divide-slate-200 dark:divide-slate-800">
              <tr>
                <td class="px-4 py-2 align-top"><code>rule</code></td>
                <td class="px-4 py-2 align-top">Human readable name of the rule.</td>
                <td class="px-4 py-2 align-top">Text value.</td>
                <td class="px-4 py-2 align-top">Required. Used in monitor output and explanations.</td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>priority</code></td>
                <td class="px-4 py-2 align-top">Controls evaluation order and conflict resolution.</td>
                <td class="px-4 py-2 align-top">Integer, higher means earlier evaluation.</td>
                <td class="px-4 py-2 align-top">
                  Optional. Defaults to zero when omitted.
                </td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>if</code></td>
                <td class="px-4 py-2 align-top">Specifies conditions for rule firing.</td>
                <td class="px-4 py-2 align-top">
                  May be a single expression string or a structured logical mapping.
                </td>
                <td class="px-4 py-2 align-top">
                  May be omitted. A rule without conditions always matches.
                </td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>let</code></td>
                <td class="px-4 py-2 align-top">Defines helper values for use in conditions and actions.</td>
                <td class="px-4 py-2 align-top">Mapping from variable names to expressions.</td>
                <td class="px-4 py-2 align-top">
                  Variables cannot reference themselves directly.
                </td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>then</code></td>
                <td class="px-4 py-2 align-top">Describes which paths to write when the rule fires.</td>
                <td class="px-4 py-2 align-top">Mapping from target paths to expressions.</td>
                <td class="px-4 py-2 align-top">
                  Required for rules that are expected to change facts.
                </td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>reason</code></td>
                <td class="px-4 py-2 align-top">
                  Explanation text used in monitoring and justification.
                </td>
                <td class="px-4 py-2 align-top">Text value.</td>
                <td class="px-4 py-2 align-top">Strongly recommended for explainability.</td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>stop</code></td>
                <td class="px-4 py-2 align-top">
                  Indicates whether engine evaluation should stop after this rule fires.
                </td>
                <td class="px-4 py-2 align-top">Boolean value.</td>
                <td class="px-4 py-2 align-top">
                  Use sparingly when early stopping is clearly required.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- EXPRESSIONS AND FUNCTIONS -->
      <section id="expressions" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">8. Expressions and functions</h2>
        <p>
          SESL supports a range of operators and functions that can be used in conditions, helper expressions (<code>let</code> blocks),
          and action assignments. This section covers the syntax and behavior of these operators and built-in functions.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.1 Operand types and type system</h3>
        <p>
          SESL supports a dynamic type system, meaning variables can hold different types of values and the engine is intelligent about 
          converting between types when appropriate. However, you can enforce strict type checking if you want additional safety. The primary 
          types are:
        </p>

        <p class="mb-2">
          <strong>Boolean:</strong> True or false values, used in conditions and logical operations. Booleans are the result of comparisons and 
          logical operations.
        </p>

        <p class="mb-2">
          <strong>Number:</strong> Integer or floating-point values used in comparisons and arithmetic. SESL automatically handles conversion 
          between integers and floats for operations like division.
        </p>

        <p class="mb-2">
          <strong>String:</strong> Text values enclosed in single or double quotes. Strings support concatenation and can be compared using 
          comparison operators.
        </p>

        <p class="mb-2">
          <strong>List:</strong> Ordered collections of values, typically used with the <code>in</code> and <code>not in</code> operators to 
          test membership. Lists are also returned by certain functions.
        </p>

        <p class="mb-2">
          <strong>Mapping:</strong> Key-value structures that form the nested fact hierarchy. Most values in your facts are mappings 
          (dictionaries/objects).
        </p>

        <p>
          <strong>None/null:</strong> The absence of a value, used to test whether fields are unset. You can check for null values using the 
          <code>is None</code> operator.
        </p>

        <p class="mt-3">
          When <code>SESL_STRICT_OPERANDS</code> is enabled in configuration, the engine enforces type compatibility in expressions and reports 
          errors when operations don't make sense (like adding a number and a string). In relaxed mode (the default), automatic type coercion is 
          applied where sensible, for example converting "123" (string) to 123 (number) if used in arithmetic.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.2 Comparison operators</h3>
        <p>
          Comparison operators test relationships between values and return either true or false. These operators are fundamental to writing 
          conditions in your rules.
        </p>

        <p class="mb-3">
          <code>==</code> tests whether two values are equal. It works for all types. For example, <code>"customer.status == 'active'"</code> 
          returns true if the customer status is exactly 'active'.
        </p>

        <p class="mb-3">
          <code>!=</code> tests whether two values are not equal. For example, <code>"result.decision != 'pending'"</code> returns true if the 
          decision is anything other than 'pending'.
        </p>

        <p class="mb-3">
          <code>&gt;</code> and <code>&gt;=</code> test whether the left value is greater than (or greater than or equal to) the right value. 
          These work with numbers and also with strings (using alphabetical order). For example, <code>"applicant.income > 30000"</code> returns 
          true if income exceeds 30,000.
        </p>

        <p class="mb-3">
          <code>&lt;</code> and <code>&lt;=</code> test whether the left value is less than (or less than or equal to) the right value.
        </p>

        <p class="mb-3">
          <code>in</code> tests whether the left value is a member of the right value (which should be a list or container). For example, 
          <code>"customer.country in const.approved_countries"</code> returns true if the customer's country appears in your approved countries list.
        </p>

        <p class="mb-3">
          <code>not in</code> is the opposite of <code>in</code>. For example, <code>"applicant.state not in const.restricted_states"</code> 
          returns true if the state is not in your restricted states list.
        </p>

        <p class="mb-3">
          <code>is None</code> tests whether a value is null or missing. For example, <code>"result.flags is None"</code> returns true if the 
          flags field does not exist or is explicitly set to null.
        </p>

        <p>
          <code>is not None</code> is the opposite of <code>is None</code>. It returns true when a value exists and is not null. This is useful 
          for checking whether required fields have been set.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.3 Logical operators and boolean logic</h3>
        <p>
          Boolean operators combine multiple conditions into more complex logic. They work with values that are true or false, and they return 
          true or false as their result.
        </p>

        <p class="mb-2">
          <code>and</code> requires all conditions to be true. For example, <code>"applicant.age >= 21 and applicant.income > 30000"</code> is 
          true only when both conditions are true: the applicant is at least 21 years old AND earns more than 30,000.
        </p>

        <p class="mb-2">
          <code>or</code> requires at least one condition to be true. For example, <code>"customer.is_vip or customer.lifetime_value > 100000"</code> 
          is true if the customer is VIP OR has lifetime value exceeding 100,000 (or both).
        </p>

        <p class="mb-2">
          <code>not</code> inverts the truth value. For example, <code>"not customer.is_flagged"</code> is true when the customer is not flagged.
        </p>

        <p>
          For very complex boolean logic with many nested conditions, SESL recommends using the structured <code>all</code>, <code>any</code>, 
          and <code>not</code> blocks in the <code>if</code> section of rules (see section 7.2). These are clearer and easier to maintain than 
          deeply nested inline boolean expressions.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.4 Arithmetic operators</h3>
        <p>
          Arithmetic operators perform mathematical calculations on numeric values. When you use these operators, SESL automatically ensures both 
          operands are numbers, either through coercion or (in strict mode) by raising an error if they are not.
        </p>

        <p class="mb-2">
          <code>+</code> performs addition. For example, <code>"base_score + bonus"</code> adds two numbers. The <code>+</code> operator also works 
          with strings for concatenation (combining them together).
        </p>

        <p class="mb-2">
          <code>-</code> performs subtraction. For example, <code>"total_price - discount_amount"</code> subtracts one number from another.
        </p>

        <p class="mb-2">
          <code>*</code> performs multiplication. For example, <code>"quantity * unit_price"</code> multiplies two numbers.
        </p>

        <p class="mb-2">
          <code>/</code> performs division and always returns a floating-point result. For example, <code>"total_debt / income"</code> computes 
          the debt-to-income ratio. Note that dividing by zero will raise an error.
        </p>

        <p class="mb-2">
          <code>//</code> performs integer division, rounding down to the nearest whole number. For example, <code>"total_amount // batch_size"</code> 
          tells you how many complete batches fit into a total.
        </p>

        <p class="mb-2">
          <code>%</code> returns the remainder (modulo) after division. For example, <code>"transaction_count % 10"</code> returns the remainder 
          after dividing by 10.
        </p>

        <p>
          <code>**</code> raises a number to a power (exponentiation). For example, <code>"interest_rate ** years"</code> computes compound growth. 
          Note that raising 0 to a negative power will raise an error.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.5 Operator precedence and grouping</h3>
        <p>
          When an expression contains multiple operators, SESL evaluates them in a specific order, following standard mathematical conventions. 
          Understanding precedence is important to avoid unexpected results.
        </p>

        <p class="mb-2">
          SESL follows this precedence, from highest priority (evaluated first) to lowest priority (evaluated last):
        </p>

        <ol class="mb-3">
          <li><strong>Parentheses:</strong> <code>(...)</code> â€“ Always evaluated first, allowing you to override normal precedence</li>
          <li><strong>Exponentiation:</strong> <code>**</code> â€“ Raises a number to a power</li>
          <li><strong>Unary negation:</strong> <code>-x</code>, <code>not x</code> â€“ Applied to a single value</li>
          <li><strong>Multiplication, division, modulo:</strong> <code>*, /, //, %</code> â€“ Evaluated left to right</li>
          <li><strong>Addition, subtraction:</strong> <code>+, -</code> â€“ Evaluated left to right</li>
          <li><strong>Comparisons:</strong> <code>==, !=, &gt;, &gt;=, &lt;, &lt;=, in, not in, is, is not</code> â€“ Evaluated left to right</li>
          <li><strong>Logical AND:</strong> <code>and</code> â€“ All conditions must be true</li>
          <li><strong>Logical OR:</strong> <code>or</code> â€“ At least one condition must be true</li>
        </ol>

        <p>
          Use parentheses to make complex expressions explicit and to ensure your intent is clear. For example, without parentheses 
          <code>"a + b * c"</code> is different from <code>"(a + b) * c"</code> because multiplication has higher precedence. Using parentheses 
          makes your model easier to understand and less prone to mistakes.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.6 Built-in functions</h3>
        <p>
          SESL provides a set of built-in functions that handle common operations. These functions can be used anywhere an expression can be used: 
          in conditions, in let blocks, and in then actions. Using functions reduces complexity and makes your rules more readable.
        </p>

        <p class="mb-2">
          <code>max(a, b)</code> returns the greater of two values. For example, <code>"max(applicant.income, minimum_income)"</code> ensures you 
          use at least the minimum income in calculations, even if the applicant's actual income is lower.
        </p>

        <p class="mb-2">
          <code>min(a, b)</code> returns the lesser of two values. For example, <code>"min(transaction.amount, limit)"</code> ensures the transaction 
          does not exceed your maximum limit.
        </p>

        <p class="mb-2">
          <code>abs(x)</code> returns the absolute value (magnitude without sign). For example, <code>"abs(variance)"</code> converts a variance that 
          might be negative to its positive magnitude.
        </p>

        <p class="mb-2">
          <code>len(x)</code> returns the length of a list or string. For example, <code>"len(customer.addresses)"</code> tells you how many addresses 
          a customer has, or <code>"len(applicant.name)"</code> tells you the number of characters in a name.
        </p>

        <p class="mb-2">
          <code>sum(list)</code> sums all numbers in a list. For example, <code>"sum(transaction.amounts)"</code> computes the total of all transaction 
          amounts.
        </p>

        <p class="mb-2">
          <code>avg(list)</code> and <code>mean(list)</code> compute the average (mean) of a list of numbers. For example, <code>"avg(monthly_expenses)"</code> 
          tells you the average expense per month.
        </p>

        <p class="mb-2">
          <code>round(x, n)</code> rounds a number to n decimal places. For example, <code>"round(calculated_rate, 2)"</code> rounds to 2 decimal places, 
          suitable for percentages.
        </p>

        <p class="mb-2">
          <code>floor(x)</code> rounds down to the nearest integer. For example, <code>"floor(score)"</code> converts 85.7 to 85.
        </p>

        <p class="mb-2">
          <code>ceil(x)</code> rounds up to the nearest integer. For example, <code>"ceil(cost)"</code> converts 99.1 to 100, useful when you want to 
          round up any partial amount to the next whole unit.
        </p>

        <p class="mb-2">
          <code>str(x)</code> converts a value to a string. For example, <code>"str(applicant.id)"</code> converts an ID number to text.
        </p>

        <p class="mb-2">
          <code>int(x)</code> converts a value to an integer. For example, <code>"int(score_string)"</code> converts the string "85" to the number 85.
        </p>

        <p>
          <code>bool(x)</code> converts a value to a boolean (true or false). For example, <code>"bool(flag_value)"</code> ensures the result is a 
          proper boolean.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.7 String operations</h3>
        <p>
          SESL supports basic string operations for working with text values. Strings are enclosed in single or double quotes and can be compared, 
          combined, and searched.
        </p>

        <p class="mb-2">
          <strong>Concatenation:</strong> Use the <code>+</code> operator to combine strings. For example, <code>"'Hello, ' + customer.name"</code> 
          combines the greeting with the customer's name. You can concatenate multiple strings and even mix strings with numbers (the numbers are 
          automatically converted to strings).
        </p>

        <p class="mb-2">
          <strong>String comparison:</strong> Use comparison operators like <code>==</code> and <code>!=</code> to check string values. For example, 
          <code>"applicant.status == 'active'"</code> checks whether the status is exactly 'active'. String comparisons are case-sensitive by default.
        </p>

        <p class="mb-2">
          <strong>Membership:</strong> Check if a substring exists within a string using the <code>in</code> operator. For example, <code>"'restricted' in document_text"</code> 
          returns true if the word 'restricted' appears anywhere in the document text.
        </p>

        <p>
          <strong>Case methods:</strong> The methods <code>.lower()</code> and <code>.upper()</code> convert strings to lowercase or uppercase respectively. 
          For example, <code>"customer.name.lower()"</code> converts a customer name to all lowercase, useful for case-insensitive comparisons.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.8 Expression context and scope</h3>
        <p>
          Expressions can reference different sources of data depending on where they appear in your rules. Understanding what is available in each 
          context helps you write correct and clear expressions.
        </p>

        <p class="mb-2">
          <strong>In condition expressions</strong> (the <code>if</code> field), you can reference facts via dot notation (like <code>customer.age</code>), 
          constants via the <code>const.</code> prefix (like <code>const.minimum_age</code>), and helper variables from the enclosing <code>let</code> block.
        </p>

        <p class="mb-2">
          <strong>In let blocks</strong>, you can reference facts, constants, and previously defined helper variables. However, a variable cannot 
          reference itself (self-referential expressions are a compile-time error). Variables are evaluated in order, so earlier variables are 
          available to later ones.
        </p>

        <p>
          <strong>In then actions</strong>, you can reference facts, constants, helper variables, and the special <code>result</code> namespace. 
          You can also reference previously written result values within the same then block, allowing you to build up complex output values step by step.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.9 Expression examples</h3>
        <p>
          Here are some realistic expression examples to help you understand how to use expressions in practice:
        </p>
        <pre><code># Simple arithmetic
then:
  result.total: "item_price * quantity"

# Conditional using max
let:
  effective_income: "max(applicant.income, applicant.spouse_income)"

# Boolean combination
if: "applicant.age >= 18 and applicant.credit_score > 620"

# String concatenation
then:
  result.message: "'Risk level: ' + result.risk_band"

# Complex arithmetic with functions
let:
  debt_ratio: "total_debt / max(applicant.income, 1)"
if: "debt_ratio > 0.5 or applicant.income < min_income"

# List operations
if: "applicant.country in const.approved_countries"
then:
  result.discount_rate: "0.15"</code></pre>
      </section>

      <!-- FACTS STRUCTURE -->
      <section id="facts-structure" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">9. Facts structure</h2>
        <p>
          Facts represent the input data that rules operate on. They are the raw information that your application gathers 
          from users, databases, or external services. Facts are structured as nested mappings (dictionaries or objects) of 
          keys to values. The SESL engine treats the top level of the facts mapping as the main namespace where rules read and 
          write values using dot-separated paths like <code>customer.age</code> or <code>result.decision</code>.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">9.1 Facts inside a model file</h3>
        <p>
          Within a SESL model file, the <code>facts</code> section is a list of test scenarios. Each scenario has its own copy 
          of the facts mapping, allowing you to test your rules against different input combinations. When you run the model file 
          through the engine, it evaluates the rules once for each scenario.
        </p>

        <p class="mb-2">
          Here is a typical facts structure:
        </p>
        <pre><code>facts:
  - name: "Young customer"
    customer:
      age: 22
      country: "United Kingdom"
    result: {}

  - name: "Senior customer"
    customer:
      age: 70
      country: "United Kingdom"
    result: {}</code></pre>

        <p class="mb-2">
          Notice how the first scenario is named "Young customer" and contains customer information (age and country). The second 
          scenario is "Senior customer" with different age but same country. Each scenario starts with an empty <code>result</code> 
          mapping, which the rules will populate when they execute.
        </p>

        <p class="mb-2">
          A key pattern in SESL is to use nested keys to group related information. In the example above, all customer data is 
          grouped under the <code>customer</code> key. This keeps your facts organized and makes rules easier to read and maintain. 
          You might have other top-level keys like <code>application</code>, <code>credit_report</code>, <code>transaction</code>, and so on.
        </p>

        <p>
          Including an initial <code>result</code> mapping (even if empty) makes your intent clear. Although the engine will automatically 
          create a result mapping if it is missing, explicitly including it documents that you expect rules to write output into this 
          section. This convention improves code clarity.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">9.2 Engine metadata in facts</h3>
        <p>
          When the SESL engine runs, it stores its own internal metadata under a reserved top level key named <code>_sesl</code>. 
          This namespace is entirely managed by the engine and you should not access it from your rules.
        </p>

        <p class="mb-2">
          The <code>_sesl</code> namespace contains several types of information. First, it holds a snapshot of the original facts 
          as they were when the engine started, which is useful for comparison and rollback scenarios. Second, it stores support 
          information for truth maintenance, tracking which rules produced which facts so that when a fact becomes invalid, the 
          engine can determine which other facts depend on it. Third, it includes monitoring information about which rules fired, 
          how conditions were evaluated, and execution metrics. Fourth, it contains a copy of the configuration settings used for 
          the current run.
        </p>

        <p>
          Since <code>_sesl</code> is reserved for engine data, you should never write facts under this key in your rules. If you 
          do, the engine will either ignore them or raise an error, depending on configuration. Avoid using keys that start with 
          underscore in your own facts to prevent accidental conflicts.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">9.3 How rules consume facts</h3>
        <p>
          Rules access facts using dot-separated path notation. A path describes a route through your nested facts structure. 
          For example, <code>customer.age</code> means "look at the customer object and get the age field." Similarly, <code>result.score</code> 
          means "look at the result object and get the score field."
        </p>

        <p class="mb-2">
          When the engine evaluates a rule, it resolves these paths by traversing the facts mapping. If the path exists, the engine 
          retrieves the value. If the path does not exist, the engine returns a null or missing value, depending on the configuration mode.
        </p>

        <p>
          In strict path mode (controlled by the <code>SESL_STRICT_PATHS</code> configuration option), the engine raises an error when 
          it encounters a missing path. This protects you from subtle mistakes such as misspelling a key. For example, if you write 
          <code>customer.age</code> but the actual key is <code>customer.aget</code>, strict mode will catch this typo and alert you. In 
          relaxed mode, the engine returns a null value for missing paths, allowing rules to handle missing data gracefully.
        </p>
      </section>

      <!-- ENGINE CONFIGURATION -->
      <section id="config" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">10. Engine configuration</h2>
        <p>
          The SESL engine behavior can be customized through configuration settings. These settings control how strictly the engine 
          checks types and paths, how it handles missing values, and how it reports errors. Different applications have different 
          requirementsâ€”a financial application might need strict type checking, while a customer service application might prefer 
          lenient handling of missing data. Configuration allows you to tune the engine's behavior to match your needs.
        </p>

        <p>
          Configuration can be set in three different ways: via environment variables that apply globally to the entire system, via 
          configuration objects passed directly to the engine function, or by relying on sensible defaults. We will explore each approach.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">10.1 Environment variables</h3>
        <p>
          Environment variables provide a convenient way to configure the engine globally. These settings are checked when the engine 
          initializes and apply to all rules in all models run in that environment. This is useful for setting global policies across 
          your entire application.
        </p>

        <p class="mb-2">
          <code>SESL_STRICT_OPERANDS</code> (true or false) controls whether the engine enforces type compatibility in expressions. When 
          set to true, the engine will refuse operations that mix types without explicit conversion. For example, it will not add a 
          string to a number; you must explicitly convert one or both to a compatible type. This prevents subtle bugs where a "123" string 
          might unexpectedly behave like the number 123. Default: false (relaxed mode allows coercion).
        </p>

        <p class="mb-2">
          <code>SESL_STRICT_PATHS</code> (true or false) controls whether the engine requires all intermediate structures to exist before 
          you write to a path. When true, writing to <code>result.flags.high_risk</code> requires that both <code>result</code> and 
          <code>result.flags</code> already exist as objects. This prevents typos where you might accidentally create <code>result.flgas</code> 
          instead of <code>result.flags</code>. Default: false (relaxed mode creates missing structures).
        </p>

        <p class="mb-2">
          <code>SESL_AUTO_CREATE_PATHS</code> (true or false) controls whether the engine automatically creates missing intermediate structures 
          when writing to paths. When true, writing to <code>result.nested.deep.field</code> will automatically create any missing intermediate 
          objects. This is convenient for rapid development but can hide typos. Default: true (automatic creation enabled). Note that this 
          setting is ignored if SESL_STRICT_PATHS is true.
        </p>

        <p class="mb-2">
          <code>SESL_ERROR_STYLE</code> (fancy or plain) controls whether error messages include formatting and colors. Fancy mode produces 
          colorful, visually formatted error messages useful for development. Plain mode produces simple text suitable for logging systems 
          that don't support colors. Default: fancy.
        </p>

        <p class="mb-2">
          <code>SESL_CONFLICT_POLICY</code> (error, warn, or ignore) controls how the engine handles conflicting writes. A conflict occurs when 
          multiple rules at the same priority level try to write different values to the same path in the same iteration. The error policy 
          raises an exception, the warn policy logs a warning and picks one value, and the ignore policy silently picks one value. Default: warn.
        </p>

        <p>
          <code>SESL_MAX_ITERATIONS</code> (integer) sets the maximum number of forward chaining iterations. This prevents infinite loops if your 
          rules form a cycle that continuously updates facts. When the limit is reached, the engine stops and returns the current state. Default: 20.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">10.2 Configuration via function arguments</h3>
        <p>
          Configuration can also be passed directly to the <code>forward_chain</code> function via a configuration object. This approach allows 
          you to override environment variables and defaults for specific runs without modifying system settings.
        </p>

        <pre><code>from sesl_engine import forward_chain, EngineConfig

config = EngineConfig(
    strict_operands=True,
    strict_paths=False,
    auto_create_paths=True,
    error_style="fancy",
    conflict_policy="warn",
    max_iterations=20
)

forward_chain(rules, facts, config=config, monitor=monitor)</code></pre>

        <p>
          This pattern is useful when you want different configurations for different parts of your application. For example, your high-stakes 
          approval engine might use strict checking, while your analytics engine might use relaxed checking for flexibility.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">10.3 Configuration precedence</h3>
        <p>
          When the engine needs to know a configuration value, it checks multiple sources and uses the highest-priority source available. 
          Understanding this precedence helps you set configuration predictably across your application.
        </p>

        <p class="mb-2">
          The precedence order from highest to lowest is:
        </p>

        <ol class="mb-3">
          <li><strong>Function arguments:</strong> Configuration passed directly to <code>forward_chain</code> via the <code>config=</code> parameter has the highest priority</li>
          <li><strong>Environment variables:</strong> Settings like <code>SESL_STRICT_OPERANDS</code> are checked second</li>
          <li><strong>Engine defaults:</strong> Built-in defaults are used if no function arguments or environment variables are set</li>
        </ol>

        <p>
          This design allows you to set global defaults via environment variables while overriding them for specific runs. For instance, you 
          might set <code>SESL_STRICT_OPERANDS=false</code> globally for development, but pass <code>config=EngineConfig(strict_operands=True)</code> 
          when running your production approval engine.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">10.4 Strict mode recommendations</h3>
        <p>
          Different applications have different safety requirements. We recommend enabling strict modes in production to catch subtle bugs early. 
          The right configuration depends on your use case and risk tolerance.
        </p>

        <p class="mb-2">
          For financial calculations, loan approvals, and other high-stakes decisions where correctness is critical, we strongly recommend setting 
          <code>strict_operands=True</code>. This forces explicit type conversions and catches type mismatches, preventing unexpected behavior. 
          Without strict mode, a string "100" might accidentally be treated as the number 100, leading to wrong decisions.
        </p>

        <p class="mb-2">
          For models that process structured input data, set <code>strict_paths=True</code> with <code>auto_create_paths=False</code>. This ensures 
          all paths are explicitly defined in your facts before rules write to them. If a rule tries to write to a path that doesn't exist, the 
          engine raises an error immediately rather than silently creating it. This catches typos and missing initialization issues early.
        </p>

        <p>
          For production models where multiple rules might write to the same path, set <code>conflict_policy="error"</code>. This treats conflicting 
          writes as errors rather than warnings, ensuring you are aware of any ambiguities in your rule set. This promotes deterministic behavior 
          and prevents subtle race conditions where the order of rules might affect results.
        </p>
      </section>

      <!-- VALIDATION AND LINTING -->
      <section id="validation" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">11. Validation and linting</h2>
        <p>
          Before running a SESL model in production, it is important to validate that the model is well-formed and that rules do not 
          contain obvious errors. Mistakes in rule logic can have serious consequencesâ€”approving ineligible applicants, denying eligible 
          ones, or applying incorrect discounts. SESL provides several validation and linting tools to help you identify and fix issues 
          early in your development process, before they reach production.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">11.1 Preflight validation</h3>
        <p>
          Preflight validation is automatic and happens immediately when you load a model file using <code>load_model_from_yaml</code>. 
          This first pass checks the basic structure and syntax of your model before the engine tries to execute it.
        </p>

        <p class="mb-2">
          Preflight validation checks several important things. First, it verifies that the YAML syntax is correct. YAML is sensitive 
          to indentation and special characters, so syntax errors are common. Second, it confirms that all required fields are present 
          in each rule, such as the <code>rule</code> name and the <code>then</code> section. Third, it checks that all rule names are 
          unique within the modelâ€”if you accidentally define two rules with the same name, the engine will catch this. Fourth, it scans 
          for obviously missing references, such as constants that are used in rules but never defined in the <code>const</code> section.
        </p>

        <p>
          If preflight validation fails, a clear and descriptive error message is raised immediately, telling you exactly what went wrong 
          and where to find it in your model file. This means you can fix problems quickly without waiting to run the full engine.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">11.2 Model linting</h3>
        <p>
          In addition to basic validation, SESL provides a linter that performs much deeper semantic analysis. The linter looks beyond 
          simple syntax and structure to understand the logic of your rules and find potential problems.
        </p>

        <p class="mb-2">
          Here is how to run the linter on your model:
        </p>
        <pre><code>from sesl_engine.tools.linter_core import lint_model_from_yaml

model_text = open("my_model.sesl.yaml").read()
lints, errors = lint_model_from_yaml(model_text)

for lint in lints:
    print(f"Warning: {lint.message} at rule '{lint.rule_name}'")

for error in errors:
    print(f"Error: {error.message}")</code></pre>

        <p class="mb-2">
          The linter returns two lists: errors (which indicate serious problems that should be fixed) and lints (which are warnings about 
          potential issues that you might want to address). You can use this information to improve your model before it reaches production.
        </p>

        <p>
          The linter checks for several categories of problems. First, <strong>unused variables</strong>â€”helper variables defined in 
          <code>let</code> blocks that are never referenced anywhere. These indicate incomplete logic or leftover code from refactoring. 
          Second, <strong>unreachable code</strong>â€”rules that can never fire because their conditions are logically impossible or contradictory. 
          Third, <strong>suspicious patterns</strong>â€”rules that write to facts without reading any input (suggesting they might be incorrect), 
          or complex conditions that are hard to understand and therefore hard to maintain. Fourth, <strong>type mismatches</strong>â€”operations 
          that combine incompatible types (when strict mode is enabled). Fifth, <strong>missing documentation</strong>â€”fields that are written 
          by rules but never have an explanation or reason provided.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">11.3 Dependency analysis</h3>
        <p>
          The SESL engine can analyze the dependencies between your rules, showing which rules depend on values produced by other rules. 
          This dependency analysis helps you understand rule ordering and identify potential conflicts or circular dependencies.
        </p>

        <p class="mb-2">
          Here is how to use the dependency analysis tool:
        </p>
        <pre><code>from sesl_engine import build_dependency_graph

graph = build_dependency_graph(rules)

# Each rule shows which other rules it depends on
for rule in rules:
    dependencies = graph.get_dependencies(rule.name)
    print(f"{rule.name} depends on: {dependencies}")</code></pre>

        <p class="mb-2">
          Understanding dependencies is useful for several reasons. First, it helps you reorder rules to improve clarityâ€”even though the 
          engine automatically reorders rules based on dependencies, explicitly arranging them in your model file makes the logic easier 
          for humans to follow. Second, it helps you identify potential circular dependencies where Rule A depends on Rule B and Rule B 
          depends on Rule A. The engine prevents circular dependencies from causing infinite loops, but they indicate design issues that 
          should be addressed. Third, dependency analysis helps when refactoring large models into smaller, more focused sub-modelsâ€”you 
          can group rules that depend on each other into separate files.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">11.4 Testing and scenario validation</h3>
        <p>
          The <code>facts</code> section of a SESL model serves dual purposes: it provides test data for learning and experimenting, and 
          it acts as a regression test suite to catch unexpected changes in rule behavior. Each fact scenario can be run independently to 
          verify that rules behave as expected.
        </p>

        <p class="mb-2">
          Here is a common pattern for testing your rules against all scenarios:
        </p>
        <pre><code>rules, scenarios = load_model_from_yaml(model_text)

for scenario_name, facts in scenarios:
    monitor = Monitor()
    forward_chain(rules, facts.copy(), monitor=monitor)
    
    # Verify expected outcomes
    assert facts["result"]["decision"] in ["approve", "decline"], f"Scenario {scenario_name} produced unexpected result"
    print(f"âœ“ Scenario {scenario_name} passed")</code></pre>

        <p class="mb-2">
          This approach allows you to maintain a suite of test cases alongside your rules. When you modify your rules, you can run this test 
          suite to ensure that changes do not break expected behavior. For example, if you change the income threshold in one rule, your tests 
          will immediately tell you if this change affected the outcomes of your test scenarios in unexpected ways.
        </p>

        <p>
          Best practice is to include test scenarios that cover the important decision boundaries in your model. For instance, if your model 
          determines loan eligibility based on credit score, include scenarios just above and just below the eligibility threshold. This way, 
          if someone accidentally changes the threshold value, your tests will catch it immediately.
        </p>
      </section>

      <!-- ENGINE -->
      <section id="engine" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">12. How the SESL engine works</h2>
        <p>
          The SESL engine is a forward chaining inference engine implemented in Python. It is designed to be transparent and predictable, 
          so you understand exactly how it arrives at decisions. This section explains the internal workings of the engine, which helps you 
          write better rules and debug unexpected results.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">12.1 High level architecture</h3>
        <p>
          The SESL engine follows a multi-stage pipeline to process rules and facts. Understanding these stages helps you know what happens 
          at each step and when errors might be detected.
        </p>

        <p class="mb-2">
          <strong>Stage 1: Model Loading</strong> begins when you call the <code>load_model_from_yaml</code> function. This function reads 
          your YAML model file as text and parses it into internal structures. It extracts the rules, constants, and fact scenarios. This 
          stage outputs compiled rules ready for execution and organized fact scenarios ready for testing.
        </p>

        <p class="mb-2">
          <strong>Stage 2: Preflight Validation</strong> happens automatically as part of model loading. The <code>preflight_validate_model</code> 
          function performs inexpensive checks such as verifying that all rule names are unique, that YAML syntax is correct, and that obviously 
          missing constants or paths are caught. This stage is fast and runs every time you load a model.
        </p>

        <p class="mb-2">
          <strong>Stage 3: Dependency Ordering</strong> analyzes relationships between rules. Rules are sorted by priority (higher priority first) 
          and then by data dependencies (rules that produce data come before rules that consume it). This intelligent reordering ensures rules 
          execute in an order that respects their dependencies.
        </p>

        <p class="mb-2">
          <strong>Stage 4: Forward Chaining</strong> is when the actual inference happens. The <code>forward_chain</code> function repeatedly 
          evaluates rule conditions and applies actions until no more facts change or the iteration limit is reached. This is the "thinking" 
          part of the engine where decisions are made.
        </p>

        <p>
          <strong>Stage 5: Explainability and Metrics</strong> happens throughout execution. The optional <code>Monitor</code> class records 
          detailed information about which rules fired, which conditions were evaluated, and what changed. This information is essential for 
          understanding and explaining decisions to users and auditors.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">12.2 Lifecycle of a single run</h3>
        <p>
          When you call <code>forward_chain</code>, the engine goes through a well-defined lifecycle. Understanding this lifecycle helps you 
          understand exactly what happens to your facts at each step.
        </p>

        <p class="mb-2">
          First, the engine receives the compiled rules and your facts mapping. It also optionally receives engine configuration settings and 
          a monitor instance for recording details. The engine immediately makes a snapshot of your starting facts, storing them for later use 
          in truth maintenance and explanations. This snapshot allows the engine to answer questions like "Which facts changed during execution?" 
          and "Why did this fact change?"
        </p>

        <p class="mb-2">
          Second, the engine attaches internal metadata under the reserved <code>_sesl</code> key of your facts. This metadata includes the 
          snapshot, configuration settings, rule information, and monitoring data. You should never write to the <code>_sesl</code> key from 
          your rules.
        </p>

        <p class="mb-2">
          Third, the engine enters a main loop that runs for at most a fixed number of iterations (typically twenty). Each iteration is a complete 
          pass through all rules. Here is what happens in each iteration:
        </p>

        <ol class="mb-2">
          <li>The engine evaluates each rule in sorted order.</li>
          <li>For each rule, it prepares a <code>_let</code> (helper variables) mapping and computes each helper expression.</li>
          <li>It evaluates the rule conditions using the current facts and helper values.</li>
          <li>If the conditions are satisfied, the engine applies actions by writing to target paths in the facts mapping.</li>
          <li>It records monitoring events, including what rule executed, which conditions were true, and what changed.</li>
        </ol>

        <p class="mb-2">
          Fourth, at the end of each iteration, the engine compares a fingerprint (hash) of the user-visible facts. If the fingerprint has not 
          changed since the previous iteration, the engine knows the facts have stabilized and it stops. The loop doesn't run the maximum iterations; 
          it stops as soon as facts stop changing. This is efficient and means your rules can converge in a few iterations rather than always running 
          to the maximum.
        </p>

        <p>
          Fifth, if all iterations complete and facts are still changing, the engine stops anyway. This prevents infinite loops from rules that 
          form cycles. It will warn you that the maximum iterations were reached, which usually indicates that your rules might have a design issue.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">12.3 Walkthrough example</h3>
        <p>
          Let's trace through a simple example to see how the engine works step by step. Consider this very small model:
        </p>
        <pre><code>model: "Simple flag demo"

rules:
  - rule: "Flag high amount"
    if: "transaction.amount &gt; 1000"
    then:
      result.flagged: true
      result.flag_reason: "High transaction amount"
    reason: "Highlight unusually large transactions"

facts:
  - name: "Transaction demo"
    transaction:
      amount: 1500
    result: {}</code></pre>

        <p class="mb-2">
          Here is how the engine processes this model:
        </p>

        <ol class="mb-3">
          <li>The engine loads one rule and one scenario with transaction amount 1500.</li>
          <li>It starts the first iteration and evaluates the rule.</li>
          <li>It evaluates the condition <code>"transaction.amount &gt; 1000"</code>. Since the amount is 1500, this is true.</li>
          <li>Because the condition is true, the engine executes the then block, writing two values: <code>result.flagged = true</code> and <code>result.flag_reason = "High transaction amount"</code>.</li>
          <li>The monitor records that the rule fired and why.</li>
          <li>At the end of the iteration, the engine compares fingerprints. The facts have changed (two new fields were added), so it checks another iteration.</li>
          <li>In the next iteration, it evaluates the same rule again. The condition is still true, but the then block would write the same values.</li>
          <li>No new facts changed this iteration, so the fingerprint matches the previous one. The engine stops.</li>
        </ol>

        <p>
          The final result would look like this:
        </p>
        <pre><code>result: {
  "flagged": true,
  "flag_reason": "High transaction amount",
  "monitor": [...],
  "monitor_blocks": [...],
  "monitor_theme": "colour"
}</code></pre>

        <p>
          In this simple example, the engine only needed two iterations to reach a stable state. More complex models with many interdependent rules 
          might need more iterations, but the principle is the same: the engine keeps going until nothing changes or the iteration limit is reached.
        </p>
      </section>

      <!-- OUTPUT -->
      <section id="output" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">13. Output and explanation</h2>
        <p>
          When you call the <code>forward_chain</code> function, the engine mutates the facts mapping in place, filling it with results from 
          rule execution. The engine also attaches several helpful structures that provide detailed information about what happened during 
          execution. This section describes the main parts of the engine output.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">13.1 Result section</h3>
        <p>
          The most important part for your application logic is the <code>result</code> mapping. This is where your rules typically write 
          decisions, scores, explanations, and other output values. The result section is entirely defined by your modelâ€”you decide what 
          fields to include and what they mean.
        </p>

        <pre><code>result: {
  "decision": "approve",
  "decision_reason": "Very high income",
  "score": 78
}</code></pre>

        <p class="mb-2">
          Common patterns for result sections include:
        </p>

        <ul class="mb-3">
          <li><strong>decision:</strong> The main outcomeâ€”approve, decline, refer, pending, or whatever options your business logic needs.</li>
          <li><strong>decision_reason:</strong> Free text explanation of why the decision was made. This is crucial for transparency.</li>
          <li><strong>score:</strong> A numeric score or rating (0-100, 0-1000, etc.) that quantifies the assessment.</li>
          <li><strong>flags:</strong> A sub-mapping with Boolean flags describing special conditions (e.g., <code>flags.requires_manual_review</code>, <code>flags.high_risk</code>).</li>
          <li><strong>confidence:</strong> A confidence level (e.g., 0-1) expressing how certain the decision is.</li>
          <li><strong>processing_time_ms:</strong> How long the evaluation took (useful for performance monitoring).</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">13.2 Monitor fields</h3>
        <p>
          When you pass a monitor instance to the engine, it records detailed information about rule execution. For convenience, this monitoring 
          information is attached to both the <code>_sesl</code> key and the <code>result</code> mapping, making it easily accessible.
        </p>

        <p class="mb-2">
          Here is an example of monitor output:
        </p>
        <pre><code>result: {
  "decision": "approve",
  "monitor": [
    {"step": 1, "message": "--- Iteration 1 ---"},
    {"step": 2, "message": "Evaluating Set high income flag", "details": {...}},
    {"step": 3, "message": "Rule Set high income flag sets result.high_income = True"},
    {"step": 4, "message": "Rule Set high income flag FIRED", "details": {...}}
  ],
  "monitor_blocks": [
    "ðŸŸ¢ Rule Set high income flag\n   â”œâ”€ Evaluation:\n   â”‚     matched: True\n   â”‚     ...",
    "ðŸŸ¢ Rule Recommend approval for very high income\n   ..."
  ],
  "monitor_theme": "colour"
}</code></pre>

        <p class="mb-2">
          The monitor output contains three fields. The <code>monitor</code> field is a list of raw events in chronological order. Each event 
          has a numeric step number, a message, and optionally detailed information about what was evaluated. This raw format is machine-readable 
          and useful for programmatic analysis.
        </p>

        <p class="mb-2">
          The <code>monitor_blocks</code> field is a list of human-readable multi-line blocks summarizing each rule's evaluation. Each block 
          shows which rule was evaluated, whether the conditions matched, what actions were taken, and whether the rule fired. These blocks are 
          formatted for easy reading and often include Unicode symbols (checkmarks, arrows, etc.) to visually indicate execution flow.
        </p>

        <p>
          The <code>monitor_theme</code> field is a hint string that indicates what presentation style was used. Common values are "colour" 
          (for colorful terminal output) or "plain" (for simple text). Your user interface can use this hint to determine how to display the 
          monitoring information to users.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">13.3 Metrics and configuration</h3>
        <p>
          The engine attaches execution metrics and configuration details under the reserved <code>_sesl</code> key of the facts mapping. This 
          information is useful for diagnostics, performance tuning, and understanding how the engine processed your model.
        </p>

        <p class="mb-2">
          Here is an example:
        </p>
        <pre><code>_sesl:
  metrics:
    iterations: 2
    rules_evaluated: 4
    rules_fired: 2
    elapsed_ms: 3.712
    convergence_fingerprint: "&lt;hash string&gt;"
  _config:
    strict_operands: true
    strict_paths: true
    auto_create_paths: false
    error_style: "fancy"
    conflict_policy: "warn"</code></pre>

        <p class="mb-2">
          The metrics section provides performance and execution information. The <code>iterations</code> field shows how many forward chaining 
          cycles the engine completed before reaching a stable state. The <code>rules_evaluated</code> field shows the total number of times the 
          engine evaluated rule conditions (this might be higher than the number of rules Ã— iterations because of complex conditions). The <code>rules_fired</code> 
          field shows how many times rules actually executed and changed facts. The <code>elapsed_ms</code> field shows the total execution time in 
          milliseconds, useful for performance monitoring. The <code>convergence_fingerprint</code> is a hash of the user-visible facts used internally 
          to detect when the state has stabilized.
        </p>

        <p>
          The _config section documents what configuration settings were used during execution. This is useful for auditing and debuggingâ€”you can 
          verify that rules were executed with the expected configuration (strict mode on or off, etc.).
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">13.4 Truth maintenance support</h3>
        <p>
          SESL maintains detailed support information tracking which rules wrote which facts. This support information is stored under <code>_sesl.support</code> 
          and <code>_sesl.support_detail</code> and can be used to explain exactly why a fact has a particular value. This is the foundation of the 
          SESL engine's explainability capabilities.
        </p>

        <p class="mb-2">
          Here is an example:
        </p>
        <pre><code>_sesl:
  support:
    "result.decision": ["Approve on high income"]
  support_detail:
    "result.decision":
      "Approve on high income":
        reason: "Applicant has very high income"
        priority: 10</code></pre>

        <p>
          The support structure maps from result paths to the list of rules that wrote those paths. The support_detail provides more context about 
          each rule, including its reason and priority. You can use the helper function <code>explain_fact(facts, "result.decision")</code> to retrieve 
          a structured justification chain for any path, which is helpful for building user-facing explanations and audit trails.
        </p>
      </section>

      <!-- TRUTH MAINTENANCE -->
      <section id="truth-maintenance" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">14. Truth maintenance and dependency tracking</h2>
        <p>
          One of the most powerful features of SESL is its ability to track and explain every fact produced by your rules. Truth maintenance 
          is the practice of recording which rules wrote which facts so that you can later explain exactly why a decision was made. This section 
          describes how truth maintenance works and how to use it to build transparent, auditable systems.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">14.1 Support information structure</h3>
        <p>
          When rules fire and write values, the SESL engine automatically records which rule wrote each value and under what conditions. This 
          information is called "support" or "provenance." It is stored in the <code>_sesl.support</code> and <code>_sesl.support_detail</code> 
          sections of the facts mapping.
        </p>

        <p class="mb-2">
          Here is an example:
        </p>
        <pre><code>_sesl:
  support:
    "result.decision": ["Approve on high income"]
    "result.score": ["Calculate base score", "Apply income bonus"]
  
  support_detail:
    "result.decision":
      "Approve on high income":
        reason: "Applicant has very high income"
        priority: 10
        rule_fired_at_iteration: 1
    
    "result.score":
      "Calculate base score":
        reason: "Starting score from applicant profile"
        priority: 50
      "Apply income bonus":
        reason: "Bonus applied for stable income"
        priority: 40</code></pre>

        <p class="mb-2">
          The <code>support</code> field is a mapping from fact paths to lists of rule names that wrote to those paths. This tells you exactly 
          which rules are responsible for each output value. The <code>support_detail</code> field provides additional context about each write 
          operation, including the rule's reason explanation, its priority, and which iteration it fired in.
        </p>

        <p>
          This structure is the foundation of SESL's explainability. Every output value can be traced back to the rules that produced it, and 
          every rule can be linked to its reason explanation. This creates a complete audit trail of how decisions were made.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">14.2 Explaining a specific fact</h3>
        <p>
          You can use the <code>explain_fact</code> helper function to construct a human-readable explanation of why a fact has its current value. 
          This function traces through the support information and compiles a structured justification.
        </p>

        <p class="mb-2">
          Here is an example of using explain_fact:
        </p>
        <pre><code>from sesl_engine import explain_fact

# After running forward_chain...
explanation = explain_fact(facts, "result.decision")

print(f"Path: {explanation.path}")
print(f"Value: {explanation.value}")
print(f"Supported by rules: {explanation.supporting_rules}")
for rule_name, details in explanation.rule_details.items():
    print(f"  - {rule_name}: {details['reason']}")</code></pre>

        <p class="mb-2">
          This produces output like:
        </p>
        <pre><code>Path: result.decision
Value: approve
Supported by rules: ['Approve on high income']
  - Approve on high income: Applicant has very high income</code></pre>

        <p>
          You can use this in your application to show users exactly why a decision was made. For example, in a loan approval system, you could 
          display "Your application was approved because: Applicant has very high income." This transparency builds trust and makes it easier to 
          explain decisions to applicants, regulators, and internal stakeholders.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">14.3 Multiple writes and conflict resolution</h3>
        <p>
          When multiple rules try to write to the same path, the support information tracks all of them, but only one value "wins" and becomes 
          the final result. The engine determines which value wins through a priority-based conflict resolution process.
        </p>

        <p class="mb-2">
          First, the engine respects rule priority. If Rule A has priority 20 and Rule B has priority 10, Rule A's value will be used. Second, 
          if two rules have the same priority and both fire in the same iteration, the conflict policy determines what happens. The default 
          conflict policy is "warn," which logs a warning but lets one rule win (the order is implementation-dependent). You can set it to "error" 
          to reject conflicting writes or "ignore" to silently pick one.
        </p>

        <p>
          The support information always records which rule's value is currently "winning" (the highest priority, most recent write). This means 
          you can explain not just why a fact has a value, but why other rules' values were rejected in favor of higher-priority rules.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">14.4 Dependency graphs and rule relationships</h3>
        <p>
          SESL can analyze your rules to build a dependency graphâ€”a visual representation of which rules read values and which rules write them. 
          This helps you understand the "flow" of data through your rule set.
        </p>

        <p class="mb-2">
          Here is how to build and query a dependency graph:
        </p>
        <pre><code>from sesl_engine import build_dependency_graph

graph = build_dependency_graph(rules)

# Find all rules that depend on a given path
depending_rules = graph.get_rules_reading(path="result.score")

# Find all paths that a rule writes to
written_paths = graph.get_written_paths(rule_name="Calculate bonus")</code></pre>

        <p class="mb-2">
          Dependency graphs are useful for several purposes. First, understanding the flow of data helps you understand what your rules do. 
          Second, you can identify which rules are safe to modify or removeâ€”if you remove a rule that no other rule depends on, nothing breaks. 
          Third, you can detect unused rules or dead codeâ€”rules that never fire or that nobody depends on. Fourth, you can refactor large models 
          to improve maintainability by grouping related rules.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">14.5 Building user interfaces with explanation data</h3>
        <p>
          The support and monitor information generated by SESL can be used to build rich user interfaces that explain decisions. Rather than 
          showing users a black box that says "approved," you can show them exactly why the decision was made and which rules were involved.
        </p>

        <p class="mb-2">
          Here are some UI patterns you can build with SESL explanation data:
        </p>

        <ul class="mb-3">
          <li><strong>Decision summary:</strong> Show the final decision and the primary rule that determined it. For example, "Your application was <strong>approved</strong> because you meet the high income threshold."</li>
          <li><strong>Rule trace:</strong> Display all rules that fired, in the order they executed, with their conditions and actions. This helps advanced users understand the logic.</li>
          <li><strong>Evidence trail:</strong> For each output field, show which rules contributed to it and why. Create a table showing each field, its value, and the supporting rules.</li>
          <li><strong>Fact path navigation:</strong> Allow users to click on any fact in the output and see which rules read or write it. This creates an interactive exploration experience.</li>
          <li><strong>What-if analysis:</strong> Show how the decision would change if a specific input was different. This helps users understand decision boundaries (e.g., "If your income were $5,000 higher, you would be approved").</li>
        </ul>

        <p>
          The monitor data (available in <code>result.monitor</code> and <code>result.monitor_blocks</code>) provides formatted text suitable for 
          rendering in logs, web pages, or interactive tools. The support data provides structured information suitable for programmatic use. Together, 
          they give you everything you need to build transparent, auditable systems.
        </p>
      </section>

      <!-- BUSINESS EXAMPLES -->
      <section id="examples" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">15. Examples: SESL in business contexts</h2>
        <p>
          This section presents five business examples that show SESL in realistic situations. Each
          example consists of a scenario description, a model fragment, sample input data, and a short
          explanation of the engine output.
        </p>

        <!-- EXAMPLE 1 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">15.1 Insurance risk assessment</h3>
        <p><strong>Scenario.</strong> An insurance company wants to flag high risk motor policies.</p>
        <pre><code>model: "Motor risk flags"

rules:
  - rule: "Flag young driver"
    if: "policy.driver_age &lt; 25"
    then:
      result.risk_flags.young_driver: true
    reason: "Driver is younger than twenty five years"

  - rule: "Flag powerful car"
    if: "policy.engine_power_kw &gt; 150"
    then:
      result.risk_flags.powerful_car: true
    reason: "Vehicle has high engine power"

  - rule: "Set overall risk band"
    let:
      has_any_flag: "result.risk_flags.young_driver or result.risk_flags.powerful_car"
    if: "has_any_flag"
    then:
      result.risk_band: "high"
    reason: "At least one high risk flag is present"

facts:
  - name: "Example policy"
    policy:
      driver_age: 22
      engine_power_kw: 160
    result: {}</code></pre>

        <p><strong>Execution.</strong></p>
        <pre><code>rules, scenarios = load_model_from_yaml(open("motor.sesl.yaml").read())
name, facts = scenarios[0]
monitor = Monitor()
forward_chain(rules, facts, monitor=monitor)
print(facts["result"])</code></pre>

        <p><strong>Interpretation.</strong></p>
        <ul>
          <li>The first rule sets <code>result.risk_flags.young_driver</code> to true.</li>
          <li>The second rule sets <code>result.risk_flags.powerful_car</code> to true.</li>
          <li>
            The third rule sees that at least one flag is set and assigns the overall
            <code>result.risk_band</code> to <code>"high"</code>.
          </li>
          <li>The explanation data shows clearly which flags led to the high risk band.</li>
        </ul>

        <!-- EXAMPLE 2 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">15.2 Banking credit scoring</h3>
        <p><strong>Scenario.</strong> A bank wants to compute a simple credit score.</p>
        <pre><code>model: "Credit score demo"

const:
  income_threshold: 30000
  low_debt_ratio: 0.3

rules:
  - rule: "Base score"
    then:
      result.score: 50
    reason: "Starting score"

  - rule: "Increase score for high income"
    if: "applicant.income &gt;= const.income_threshold"
    then:
      result.score: "result.score + 20"
    reason: "Stable income"

  - rule: "Decrease score for high debt ratio"
    let:
      debt_ratio: "applicant.total_debt / max(applicant.income, 1)"
    if: "debt_ratio &gt; 0.5"
    then:
      result.score: "result.score - 30"
    reason: "High debt compared with income"

facts:
  - name: "Applicant example"
    applicant:
      income: 40000
      total_debt: 15000
    result:
      score: 0</code></pre>

        <p><strong>Execution and outcome.</strong></p>
        <ul>
          <li>The base score rule sets the score to fifty.</li>
          <li>The high income rule adds twenty, bringing the score to seventy.</li>
          <li>The debt ratio is fifteen thousand divided by forty thousand, which is zero point three seven five.</li>
          <li>The debt ratio rule does not fire because the ratio is not greater than zero point five.</li>
          <li>The final score is seventy.</li>
        </ul>

        <!-- EXAMPLE 3 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">15.3 Retail pricing and discounts</h3>
        <p><strong>Scenario.</strong> A retailer wants to apply volume discounts.</p>
        <pre><code>model: "Volume discount"

rules:
  - rule: "Ten percent discount for ten or more items"
    if: "basket.quantity &gt;= 10"
    then:
      result.discount_rate: 0.10
    reason: "Volume discount for ten or more items"

  - rule: "Fifteen percent discount for twenty or more items"
    priority: 20
    if: "basket.quantity &gt;= 20"
    then:
      result.discount_rate: 0.15
    reason: "Higher volume discount for twenty or more items"

  - rule: "Compute total price"
    let:
      discounted_price_per_unit: "basket.unit_price * (1 - result.discount_rate)"
    then:
      result.total_price: "basket.quantity * discounted_price_per_unit"
    reason: "Apply discount rate to quantity and unit price"

facts:
  - name: "Basket example"
    basket:
      quantity: 22
      unit_price: 5.00
    result:
      discount_rate: 0.0</code></pre>

        <p><strong>Interpretation.</strong></p>
        <ul>
          <li>
            Both discount rules match, but the higher priority rule that sets fifteen percent discount
            takes ownership of <code>result.discount_rate</code>.
          </li>
          <li>
            The compute total price rule uses the final discount rate and writes the total price. With a
            quantity of twenty two and a unit price of five, the discounted price per unit is four point
            two five, giving a total price of ninety three point five.
          </li>
        </ul>

        <!-- EXAMPLE 4 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">15.4 Supply chain routing</h3>
        <p><strong>Scenario.</strong> A logistics team wants to pick a warehouse to ship from.</p>
        <pre><code>model: "Warehouse selection"

rules:
  - rule: "Prefer local warehouse"
    if:
      all:
        - "order.destination_country == 'United Kingdom'"
        - "stock.local_available &gt;= order.quantity"
    then:
      result.source_warehouse: "local"
    reason: "Destination is local and local stock is sufficient"

  - rule: "Fallback to regional warehouse"
    if: "result.source_warehouse is None and stock.regional_available &gt;= order.quantity"
    then:
      result.source_warehouse: "regional"
    reason: "Local warehouse cannot fulfil the order"

facts:
  - name: "Order example"
    order:
      destination_country: "United Kingdom"
      quantity: 50
    stock:
      local_available: 40
      regional_available: 100
    result:
      source_warehouse: null</code></pre>

        <p><strong>Outcome.</strong></p>
        <ul>
          <li>The local warehouse rule does not fire because local stock is only forty.</li>
          <li>
            The regional warehouse rule fires and sets <code>result.source_warehouse</code> to
            <code>"regional"</code>.
          </li>
          <li>
            Explainability data records that the fallback rule provided the value, together with its
            reason text.
          </li>
        </ul>

        <!-- EXAMPLE 5 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">15.5 Compliance checking</h3>
        <p><strong>Scenario.</strong> A compliance team wants to check whether a transaction breaches simple policy rules.</p>
        <pre><code>model: "Policy compliance"

const:
  maximum_single_transaction: 10000
  restricted_country_list: ["Country X", "Country Y"]

rules:
  - rule: "Flag large transaction"
    if: "transaction.amount &gt; const.maximum_single_transaction"
    then:
      result.policy_flags.large_transaction: true
    reason: "Amount is greater than policy limit"

  - rule: "Flag restricted destination country"
    if: "transaction.country in const.restricted_country_list"
    then:
      result.policy_flags.restricted_country: true
    reason: "Destination country is on the restricted list"

  - rule: "Set compliance outcome"
    let:
      any_flag: "result.policy_flags.large_transaction or result.policy_flags.restricted_country"
    if: "any_flag"
    then:
      result.compliance_outcome: "review_required"
    reason: "At least one policy flag is present"

facts:
  - name: "Payment example"
    transaction:
      amount: 12000
      country: "Country X"
    result:
      policy_flags: {}</code></pre>

        <p><strong>Outcome.</strong></p>
        <ul>
          <li>The large transaction rule fires because the amount is greater than ten thousand.</li>
          <li>The restricted country rule also fires because the destination country is in the list.</li>
          <li>
            The final outcome is <code>result.compliance_outcome</code> set to
            <code>"review_required"</code>.
          </li>
          <li>
            The monitor blocks show exactly which conditions and values led to this outcome, which helps
            when reviewing cases.
          </li>
        </ul>
      </section>

      <!-- BEST PRACTICES -->
      <section id="best-practices" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">16. Best practices and common pitfalls</h2>

        <h3 class="text-2xl font-semibold mt-6 mb-3">16.1 Organising models, rules, and facts</h3>
        <ul>
          <li>
            Use one SESL model per coherent decision area, such as one model for eligibility and another
            for pricing.
          </li>
          <li>
            Group related rules near each other and use descriptive rule names that start with a verb,
            such as â€œSet tierâ€ or â€œFlag high riskâ€.
          </li>
          <li>
            Keep example fact scenarios small and focused. Each scenario should illustrate one main path
            through the rules.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">16.2 Naming conventions</h3>
        <ul>
          <li>
            Use lower case and underscores for keys, such as <code>total_debt</code> rather than
            <code>TotalDebt</code>.
          </li>
          <li>
            Use consistent namespaces such as <code>applicant</code>, <code>customer</code>,
            <code>transaction</code>, and <code>result</code>.
          </li>
          <li>
            Use the <code>result</code> namespace only for outputs from rules, not for inputs. This keeps
            it clear which fields are derived.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">16.3 Performance considerations</h3>
        <ul>
          <li>
            Avoid unnecessary complexity in conditions. If a condition becomes very long, consider
            computing parts of it in the <code>let</code> block.
          </li>
          <li>
            Use priorities to avoid repeatedly overwriting the same path from many rules.
          </li>
          <li>
            Monitor iteration counts and rule fire counts. Unexpectedly high values may indicate cycles
            or rules that constantly flip values back and forth.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">16.4 Common pitfalls</h3>
        <ul>
          <li>
            <strong>Missing parent paths.</strong> When strict path mode is enabled and automatic path
            creation is disabled, attempting to write to <code>result.score</code> without having a
            <code>result</code> mapping leads to a helpful error. Seed <code>result: {}</code> in facts.
          </li>
          <li>
            <strong>Unquoted string literals.</strong> In strict operand mode, text values must be quoted.
            Writing <code>then: result.status: approved</code> without quotes will cause a resolution
            error.
          </li>
          <li>
            <strong>Self-referential let expressions.</strong> A helper variable cannot refer to itself.
            This is caught at compile time to prevent confusing behaviour.
          </li>
          <li>
            <strong>Conflicting writes.</strong> Multiple rules that write to the same path at the same
            priority may conflict. The engine can warn or raise an error depending on configuration.
          </li>
        </ul>
      </section>

      <!-- CONCLUSION -->
      <section id="conclusion" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">17. Conclusion and next steps</h2>
        <p>
          SESL provides a focused, transparent way to express decision logic as rules over structured
          data. You have seen how models are structured, how rules and facts interact, how the engine
          evaluates conditions and actions, and how to interpret the output and explanation data.
        </p>
        <p>Possible next steps include:</p>
        <ul>
          <li>Creating your own small model for a decision in your organisation.</li>
          <li>
            Adding more example scenarios to test edge cases and ensure that rules behave as expected.
          </li>
          <li>
            Integrating SESL into an application by building a wrapper that prepares facts and consumes
            the result and explanation structures.
          </li>
          <li>
            Exploring the monitor and truth maintenance data to build user interfaces that explain
            decisions.
          </li>
        </ul>
        <p>
          With careful model design and the engine features described in this guide, SESL can act as a
          reliable and understandable decision layer in many different domains.
        </p>
      </section>
    </article>
  </div>
</main>

  <!-- FOOTER -->
  <footer class="border-t border-slate-300 dark:border-slate-800 py-16 px-4">
    <div class="max-w-7xl mx-auto grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-10">

      <div>
        <h4 class="font-semibold mb-3">Product</h4>
        <ul class="space-y-2 text-sm text-slate-600 dark:text-slate-400">
          <li><a href="../product.html" class="hover:text-brand-600">Overview</a></li>
        </ul>
      </div>

      <div>
        <h4 class="font-semibold mb-3">Solutions</h4>
        <ul class="space-y-2 text-sm text-slate-600 dark:text-slate-400">
          <li><a href="../solutions.html" class="hover:text-brand-600">Use Cases</a></li>
        </ul>
      </div>

      <div>
        <h4 class="font-semibold mb-3">Resources</h4>
        <ul class="space-y-2 text-sm text-slate-600 dark:text-slate-400">
          <li><a href="../resources.html" class="hover:text-brand-600">Documentation</a></li>
        </ul>
      </div>

      <div>
        <h4 class="font-semibold mb-3">Company</h4>
        <ul class="space-y-2 text-sm text-slate-600 dark:text-slate-400">
          <li><a href="../about.html" class="hover:text-brand-600">About SESL</a></li>
          <li><a href="about.html#contact" class="hover:text-brand-600">Contact</a></li>
        </ul>
      </div>

    </div>

    <div class="max-w-7xl mx-auto mt-12 pt-8 border-t border-slate-300 dark:border-slate-800 flex flex-col sm:flex-row justify-between items-center gap-4">
      <div class="flex items-center gap-3">
        <img src="../assets/SESL Logo.png" class="h-7 block dark:hidden" alt="SESL Footer Logo" />
        <img src="../assets/SESL Logo Dark.png" class="h-7 hidden dark:block" alt="SESL Footer Logo Dark" />
        <span class="text-sm text-slate-600 dark:text-slate-400">Simple Expert System Language</span>
      </div>

      <div class="flex gap-4">
        <a href="#" class="text-slate-600 hover:text-brand-600 dark:text-slate-400">Twitter</a>
        <a href="#" class="text-slate-600 hover:text-brand-600 dark:text-slate-400">LinkedIn</a>
      </div>
    </div>

    <div class="text-center mt-6 text-sm text-slate-500 dark:text-slate-500">
      Â© <span id="year"></span> Oblongix. All rights reserved.
    </div>
  </footer>

<script>
  // Theme toggle
  const btn = document.getElementById("themeToggle");
  btn.addEventListener("click", () => {
    const isDark = document.documentElement.classList.toggle("dark");
    localStorage.setItem("theme", isDark ? "dark" : "light");
    btn.textContent = isDark ? "â˜€ï¸" : "ðŸŒ™";
  });
  btn.textContent = document.documentElement.classList.contains("dark") ? "â˜€ï¸" : "ðŸŒ™";

  // Mobile menu
  const mobileBtn = document.getElementById("mobileMenuBtn");
  const mobileMenu = document.getElementById("mobileMenu");
  mobileBtn.addEventListener("click", () => {
    mobileMenu.classList.toggle("hidden");
  });

  // Year
  document.getElementById("year").textContent = new Date().getFullYear();
</script>

</body>
</html>

