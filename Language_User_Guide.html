<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SESL â€“ User Guide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Comprehensive SESL user guide explaining models, rules, facts, the engine, and business examples." />

  <!-- Load dark mode before rendering -->
  <script>
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme === "dark" || (!savedTheme && window.matchMedia("(prefers-color-scheme: dark)").matches)) {
      document.documentElement.classList.add("dark");
    }
  </script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            brand: { 300: "#a5b4fc", 500: "#6366f1", 600: "#4f46e5" }
          },
          fontFamily: { sans: ["Inter", "system-ui", "Arial"] }
        }
      }
    };
  </script>
</head>

<body class="bg-white text-slate-900 dark:bg-slate-950 dark:text-slate-100 antialiased">

<!-- HEADER -->
<header class="border-b border-slate-300 bg-white/80 backdrop-blur sticky top-0 z-40 dark:border-slate-800 dark:bg-slate-950/80">
  <div class="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">

    <!-- LOGO -->
    <a href="index.html" class="flex items-center gap-3">
      <img src="SESL Logo.png" class="h-10 block dark:hidden" alt="SESL logo light" />
      <img src="SESL Logo Dark.png" class="h-10 hidden dark:block" alt="SESL logo dark" />
    </a>

    <!-- DESKTOP NAV -->
    <nav class="hidden md:flex gap-8 text-sm font-medium">
      <a href="index.html">Home</a>
      <a href="product.html">Product</a>
      <a href="solutions.html">Solutions</a>
      <a href="customers.html">Customers</a>
      <a href="resources.html" class="text-brand-600 dark:text-brand-300 font-semibold">Resources</a>
      <a href="pricing.html">Pricing</a>
      <a href="about.html">About</a>
    </nav>

    <!-- RIGHT SIDE -->
    <div class="flex items-center gap-4">
      <a href="login.html"
         class="px-4 py-2 rounded-lg border border-slate-300 text-slate-800 hover:bg-slate-200
                dark:border-slate-700 dark:text-slate-200 dark:hover:bg-slate-800
                text-sm font-medium transition-colors">
        Login
      </a>

      <button id="themeToggle"
        class="p-2 rounded-full border border-slate-300 text-slate-800 hover:bg-slate-200 
               dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800 transition-colors"
        type="button">
        ðŸŒ™
      </button>

      <!-- MOBILE MENU BUTTON -->
      <button id="mobileMenuBtn"
        class="md:hidden p-2 rounded-lg border border-slate-300 dark:border-slate-700 text-xl"
        type="button">
        â˜°
      </button>
    </div>

  </div>
</header>

<!-- MOBILE MENU -->
<div id="mobileMenu"
  class="hidden md:hidden flex-col bg-white dark:bg-slate-900 border-b border-slate-300 dark:border-slate-800 px-4 py-4 space-y-3 text-sm font-medium">

  <a href="index.html" class="block">Home</a>
  <a href="product.html" class="block">Product</a>
  <a href="solutions.html" class="block">Solutions</a>
  <a href="customers.html" class="block">Customers</a>
  <a href="resources.html" class="block text-brand-600 dark:text-brand-300">Resources</a>
  <a href="pricing.html" class="block">Pricing</a>
  <a href="about.html" class="block">About</a>

</div>

<!-- HERO -->
<section class="pt-24 pb-10 px-4 text-center">
  <div class="max-w-3xl mx-auto">
    <h1 class="text-4xl sm:text-5xl font-semibold mb-6">SESL User Guide</h1>
    <p class="text-lg text-slate-700 dark:text-slate-300">
      A complete, plain language guide to the Simple Expert System Language, covering models, rules, facts,
      the engine, and real business examples.
    </p>
  </div>
</section>

<!-- MAIN CONTENT -->
<main class="pb-24 px-4 border-t border-slate-200 dark:border-slate-800">
  <div class="max-w-7xl mx-auto grid gap-10 lg:grid-cols-[280px,1fr]">

    <!-- TABLE OF CONTENTS -->
    <aside class="lg:sticky lg:top-24 self-start">
      <div class="p-5 rounded-2xl bg-slate-50 dark:bg-slate-900/40 border border-slate-200 dark:border-slate-800">
        <h2 class="text-sm font-semibold tracking-wide text-slate-500 dark:text-slate-400 mb-3 uppercase">
          Table of contents
        </h2>
        <nav class="space-y-2 text-sm">
          <a href="#introduction" class="block hover:text-brand-600">1. Introduction to SESL</a>
          <a href="#usage" class="block hover:text-brand-600">2. What SESL is used for</a>
          <a href="#installation" class="block hover:text-brand-600">3. Installation</a>
          <a href="#quick-start" class="block hover:text-brand-600">4. Quick start</a>
          <a href="#model-structure" class="block hover:text-brand-600">5. Structure of a SESL model</a>
          <a href="#rules-structure" class="block hover:text-brand-600">6. Rules structure</a>
          <a href="#rule-statements" class="block hover:text-brand-600">7. Rule statements and syntax</a>
          <a href="#facts-structure" class="block hover:text-brand-600">8. Facts structure</a>
          <a href="#engine" class="block hover:text-brand-600">9. How the engine works</a>
          <a href="#output" class="block hover:text-brand-600">10. Output of run commands</a>
          <a href="#examples" class="block hover:text-brand-600">11. Business examples</a>
          <a href="#best-practices" class="block hover:text-brand-600">12. Best practices</a>
          <a href="#conclusion" class="block hover:text-brand-600">13. Conclusion and next steps</a>
        </nav>
      </div>
    </aside>

    <!-- GUIDE BODY -->
    <article class="prose prose-slate dark:prose-invert max-w-none">
      <!-- INTRODUCTION -->
      <section id="introduction" class="scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">1. Introduction to SESL</h2>
        <p>
          SESL is a Simple Expert System Language that allows you to express decision logic as
          clear, structured rules. Instead of hiding business logic deep inside application code,
          SESL encourages you to describe decisions in a human readable format that can be evaluated
          by a dedicated engine.
        </p>
        <p>
          A SESL model is a single text document that contains rules and example data. The engine
          reads this model, combines it with input facts, and produces a result together with rich
          explanation data. The explanation data makes it clear which rules fired, which rules were
          skipped, and why each conclusion was reached.
        </p>

        <h3 class="text-2xl font-semibold mt-8 mb-3">1.1 Main purpose of SESL</h3>
        <p>
          The main purpose of SESL is to separate decision logic from application code while keeping
          that decision logic transparent, traceable, and easy to change. SESL is especially suited
          for situations where:
        </p>
        <ul>
          <li>Non-technical users need to understand or review the rules that drive decisions.</li>
          <li>Decisions must be explained to regulators, auditors, customers, or internal reviewers.</li>
          <li>Decision logic changes frequently and should be edited without large code changes.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-8 mb-3">1.2 Typical use cases</h3>
        <p>SESL is typically used in the following scenarios:</p>
        <ul>
          <li>Eligibility checks such as loan or insurance eligibility.</li>
          <li>Risk assessment and scoring.</li>
          <li>Discount and pricing rules.</li>
          <li>Compliance checks and policy enforcement.</li>
          <li>Operational decision automation such as routing and prioritisation.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-8 mb-3">1.3 Benefits compared with alternative approaches</h3>
        <p>Compared with hard coded decision logic, SESL offers several benefits:</p>
        <ul>
          <li>
            <strong>Readability.</strong> Rules are organised in a structured text format that can be read
            and discussed by both technical and non-technical stakeholders.
          </li>
          <li>
            <strong>Explainability.</strong> The engine records which rules fired, why they fired,
            and which fields they changed.
          </li>
          <li>
            <strong>Maintainability.</strong> Rules can be added, removed, and reordered without changing
            the engine itself.
          </li>
          <li>
            <strong>Testability.</strong> Each model can include multiple fact scenarios that act as
            simple test cases.
          </li>
        </ul>
        <p>
          SESL is intentionally small and focused. It does not attempt to be a general programming
          language. Instead, it focuses on clear, declarative rule evaluation.
        </p>
      </section>

      <!-- USAGE -->
      <section id="usage" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">2. What SESL is used for</h2>
        <p>
          SESL is designed for decision problems that can be expressed as a set of rules operating on
          structured data. The rules read facts, apply conditions, and write conclusions to result
          fields.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">2.1 Types of problems</h3>
        <ul>
          <li>Binary decisions such as approve or decline, pass or fail, flag or clear.</li>
          <li>Multi-level classifications such as risk bands and rating categories.</li>
          <li>Numeric calculations that depend on conditions, such as surcharges or discounts.</li>
          <li>Aggregation of signals into a single score or recommendation.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">2.2 How SESL fits into a larger system</h3>
        <p>
          In a typical application, SESL sits alongside existing services:
        </p>
        <ol>
          <li>Your application gathers input data and builds a facts structure.</li>
          <li>Your application loads a SESL model from a model file or configuration store.</li>
          <li>The SESL engine evaluates the rules against the facts.</li>
          <li>The engine returns updated facts, including result fields and explanation data.</li>
          <li>Your application uses those results to drive user experience or downstream actions.</li>
        </ol>
      </section>

      <!-- INSTALLATION -->
      <section id="installation" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">3. Installation instructions</h2>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.1 Prerequisites</h3>
        <ul>
          <li>A recent Python interpreter (for example version three point ten or later).</li>
          <li>Permission to install Python packages on your machine.</li>
          <li>For local development, a text editor to write model files.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.2 Installing the SESL engine as a Python package</h3>
        <p>
          If SESL is available as a Python package, you can install it using the Python package manager.
          Replace <code>sesl-engine</code> with the actual package name used by your distribution.
        </p>
        <pre><code>pip install sesl-engine</code></pre>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.3 Installing SESL from source</h3>
        <ol>
          <li>Clone or download the SESL source repository.</li>
          <li>Ensure that the Python interpreter is available on your path.</li>
          <li>Install dependencies such as the YAML parser library.</li>
        </ol>
        <pre><code>git clone https://example.com/sesl.git
cd sesl
pip install -r requirements.txt</code></pre>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.4 Verifying the installation</h3>
        <p>You can verify that the engine module is importable from Python:</p>
        <pre><code>python -c "import sesl; print('SESL is available')" </code></pre>
        <p>
          If this prints the confirmation message without errors, the engine is installed correctly.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.5 Upgrading and uninstalling</h3>
        <p>To upgrade SESL to the latest version:</p>
        <pre><code>pip install --upgrade sesl-engine</code></pre>
        <p>To remove SESL:</p>
        <pre><code>pip uninstall sesl-engine</code></pre>
      </section>

      <!-- QUICK START -->
      <section id="quick-start" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">4. Quick start guide</h2>
        <p>
          This quick start shows a complete path from a very small SESL model to a running evaluation
          and a readable result. The goal is not to cover all features, but to give you a concrete
          sense of how SESL feels in practice.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">4.1 Create a minimal model file</h3>
        <p>
          Create a new text file called <code>loan-example.sesl.yaml</code>. Paste the following
          content into the file. The format is a structured text mapping with a model name, optional
          constants, rules, and fact scenarios.
        </p>
        <pre><code>model: "Loan eligibility example"

meta:
  author: "Example author"
  created: "2025-01-01"
  source: "Internal demo"

const:
  minimum_income: 25000
  high_income: 60000

rules:
  - rule: "Set high income flag"
    if: "applicant.income &gt;= const.minimum_income"
    then:
      result.high_income: true
    reason: "Applicant meets the minimum income threshold"

  - rule: "Recommend approval for very high income"
    priority: 10
    if: "applicant.income &gt;= const.high_income"
    then:
      result.decision: "approve"
      result.decision_reason: "Very high income"
    reason: "Applicant has very high income"

facts:
  - name: "Applicant A"
    applicant:
      income: 65000
    result: {}</code></pre>

        <p>This model contains two rules and one fact scenario:</p>
        <ul>
          <li>The first rule sets a flag when the income meets the minimum.</li>
          <li>The second rule decides to approve the loan for very high income.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">4.2 Running the model through Python</h3>
        <p>The provided engine exposes two main functions that you will use frequently:</p>
        <ul>
          <li><code>load_model_from_yaml(text)</code> to load rules and scenarios from a model file.</li>
          <li><code>forward_chain(rules, facts, monitor, ...)</code> to run the inference engine.</li>
        </ul>

        <p>A simple runner script could look like this:</p>
        <pre><code>import pathlib
from sesl_engine import load_model_from_yaml, forward_chain, Monitor

# Load model text
model_path = pathlib.Path("loan-example.sesl.yaml")
text = model_path.read_text(encoding="utf-8")

# Parse into rules and named scenarios
rules, scenarios = load_model_from_yaml(text)

# Take the first scenario
scenario_name, facts = scenarios[0]

# Optional monitor for explainability
monitor = Monitor(theme="colour")

# Run the engine
forward_chain(rules, facts, monitor=monitor)

# Print the result section
print("Scenario:", scenario_name)
print("Result:", facts.get("result"))
</code></pre>

        <h3 class="text-2xl font-semibold mt-6 mb-3">4.3 Understanding the output</h3>
        <p>
          After running the script, you will see a printed <code>result</code> mapping similar to the
          following:
        </p>
        <pre><code>Scenario: Applicant A
Result: {
  'high_income': True,
  'decision': 'approve',
  'decision_reason': 'Very high income',
  'monitor': [...],
  'monitor_blocks': [...],
  'monitor_theme': 'colour'
}</code></pre>
        <p>Key points:</p>
        <ul>
          <li><code>high_income</code> is set by the first rule.</li>
          <li><code>decision</code> and <code>decision_reason</code> are set by the second rule.</li>
          <li>
            <code>monitor</code> and <code>monitor_blocks</code> contain a detailed explanation of which
            rules were evaluated and which ones fired.
          </li>
        </ul>
      </section>

      <!-- MODEL STRUCTURE -->
      <section id="model-structure" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">5. Structure of a SESL model</h2>
        <p>
          A SESL model file is a structured text document that typically contains the following top level
          sections:
        </p>
        <ul>
          <li><strong>model</strong>: name or identifier of the model.</li>
          <li><strong>meta</strong>: optional metadata such as author, creation date, and usage notes.</li>
          <li><strong>const</strong>: constants that can be referenced by rules.</li>
          <li><strong>rules</strong>: a list of rule definitions.</li>
          <li><strong>facts</strong>: example input scenarios for testing and demonstration.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">5.1 Example model with annotations</h3>
        <pre><code># Model name
model: "Customer loyalty scoring"

# Optional descriptive metadata
meta:
  author: "Loyalty team"
  created: "2025-02-10"
  source: "Marketing rules"
  considerations: "Not for credit risk decisions"

# Constants shared by all rules
const:
  gold_threshold: 1000
  silver_threshold: 500

# List of rule objects
rules:
  - rule: "Set gold tier"
    priority: 20
    if: "customer.points &gt;= const.gold_threshold"
    then:
      result.tier: "gold"
    reason: "Customer points are greater than or equal to gold threshold"

  - rule: "Set silver tier"
    priority: 10
    if: "customer.points &gt;= const.silver_threshold"
    then:
      result.tier: "silver"
    reason: "Customer points are greater than or equal to silver threshold"

# Example fact scenarios
facts:
  - name: "Customer with 1200 points"
    customer:
      points: 1200
    result: {}

  - name: "Customer with 700 points"
    customer:
      points: 700
    result: {}</code></pre>

        <p>This example shows how all parts work together:</p>
        <ul>
          <li>Rules reference constants through the <code>const.</code> prefix.</li>
          <li>Each fact scenario contains an initial <code>result</code> mapping.</li>
          <li>Higher priority rules run before lower priority rules when necessary.</li>
        </ul>
      </section>

      <!-- RULES STRUCTURE -->
      <section id="rules-structure" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">6. Rules structure</h2>
        <p>
          A rule in SESL connects conditions with actions. If the conditions are satisfied, the actions
          write values into the facts structure.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">6.1 Anatomy of a rule</h3>
        <p>The engine expects each rule entry to be a mapping with fields similar to:</p>
        <pre><code>- rule: "Human readable rule name"
  priority: 10
  if: "customer.age &gt;= 18"
  let:
    age_band: "customer.age &gt;= 65"
  then:
    result.is_adult: true
  reason: "Customer has reached legal adulthood"
  stop: false</code></pre>

        <p>Important fields:</p>
        <ul>
          <li><strong>rule</strong>: required name of the rule.</li>
          <li><strong>priority</strong>: optional integer, higher values indicate higher priority.</li>
          <li><strong>if</strong>: condition or nested condition structure that must be satisfied.</li>
          <li><strong>let</strong>: optional mapping of helper variables computed before evaluating actions.</li>
          <li><strong>then</strong>: mapping of target paths to expressions to write when the rule fires.</li>
          <li><strong>reason</strong>: human readable explanation of why the rule exists.</li>
          <li><strong>stop</strong>: optional boolean. When true, the engine stops evaluating after this rule fires.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">6.2 Rule evaluation order</h3>
        <p>
          SESL evaluates rules in a deterministic order that depends on priority and data dependencies:
        </p>
        <ol>
          <li>Rules are grouped by priority. Higher priority groups are evaluated before lower ones.</li>
          <li>
            Within each priority group, the engine performs a dependency based ordering. For example,
            if one rule writes to a section that another rule reads, the writing rule is evaluated first.
          </li>
          <li>
            Within a single priority and when there are no dependencies, rules keep the original order
            from the model file.
          </li>
        </ol>
        <p>
          The engine runs several iterations until there are no more changes, or until the maximum
          number of iterations is reached. This forward chaining behaviour allows rules to build on
          values produced by other rules.
        </p>
      </section>

      <!-- RULE STATEMENTS -->
      <section id="rule-statements" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">7. Rule statements and full syntax</h2>
        <p>
          SESL supports several kinds of statements inside rules. This section describes each of them,
          together with syntax and examples.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.1 Condition expressions</h3>
        <p>
          The simplest form of a condition is a single expression string in the <code>if</code> field.
          The expression has the form:
        </p>
        <pre><code>&lt;left operand&gt; &lt;operator&gt; &lt;right operand&gt;</code></pre>
        <p>Supported comparison operators include:</p>
        <ul>
          <li><code>==</code> equal to</li>
          <li><code>!=</code> not equal to</li>
          <li><code>&gt;</code> greater than</li>
          <li><code>&gt;=</code> greater than or equal to</li>
          <li><code>&lt;</code> less than</li>
          <li><code>&lt;=</code> less than or equal to</li>
          <li><code>in</code> membership in a container</li>
          <li><code>not in</code> not a member of a container</li>
        </ul>

        <p>Example:</p>
        <pre><code>if: "customer.country == 'United Kingdom'"</code></pre>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.2 Logical condition blocks</h3>
        <p>
          For more complex conditions, the <code>if</code> field can be a structured mapping using
          logical keys <code>all</code>, <code>any</code>, and <code>not</code>.
        </p>
        <pre><code>if:
  all:
    - "customer.age &gt;= 18"
    - any:
        - "customer.country == 'United Kingdom'"
        - "customer.country == 'Ireland'"</code></pre>

        <p>Meaning:</p>
        <ul>
          <li>All listed conditions in the top level must be true.</li>
          <li>Within the <code>any</code> block, at least one condition must be true.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.3 Let statements</h3>
        <p>
          The <code>let</code> mapping allows you to define intermediate values. Each key is the name of
          a variable and each value is an expression. These expressions support arithmetic and logical
          operations on existing facts and on other previously computed variables.
        </p>

        <pre><code>let:
  income_band: "applicant.income &gt;= 80000"
  total_exposure: "existing_loans + requested_amount"</code></pre>

        <p>
          During evaluation, the engine computes each <code>let</code> entry and stores it into a special
          internal structure. You can then reference <code>income_band</code> and
          <code>total_exposure</code> inside conditions or actions.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.4 Actions in the then block</h3>
        <p>
          The <code>then</code> block is a mapping from target paths to expressions. When a rule fires,
          each target path is written with the evaluated value of its expression.
        </p>
        <pre><code>then:
  result.decision: "approve"
  result.score: "base_score + bonus"</code></pre>
        <p>Important details:</p>
        <ul>
          <li>
            Paths are dot separated sequences such as <code>result.decision</code> or
            <code>customer.flags.high_risk</code>.
          </li>
          <li>
            In strict path mode, intermediate parts such as <code>result</code> must exist unless
            automatic creation is enabled.
          </li>
          <li>
            Expressions on the right-hand side can reference facts, constants, and helper variables from
            the <code>let</code> block.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">7.5 Summary table of rule statement fields</h3>
        <div class="overflow-x-auto border border-slate-200 dark:border-slate-800 rounded-xl">
          <table class="min-w-full text-sm">
            <thead class="bg-slate-50 dark:bg-slate-900/40">
              <tr>
                <th class="px-4 py-2 text-left font-semibold">Field</th>
                <th class="px-4 py-2 text-left font-semibold">Purpose</th>
                <th class="px-4 py-2 text-left font-semibold">Key elements</th>
                <th class="px-4 py-2 text-left font-semibold">Notes</th>
              </tr>
            </thead>
            <tbody class="divide-y divide-slate-200 dark:divide-slate-800">
              <tr>
                <td class="px-4 py-2 align-top"><code>rule</code></td>
                <td class="px-4 py-2 align-top">Human readable name of the rule.</td>
                <td class="px-4 py-2 align-top">Text value.</td>
                <td class="px-4 py-2 align-top">Required. Used in monitor output and explanations.</td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>priority</code></td>
                <td class="px-4 py-2 align-top">Controls evaluation order and conflict resolution.</td>
                <td class="px-4 py-2 align-top">Integer, higher means earlier evaluation.</td>
                <td class="px-4 py-2 align-top">
                  Optional. Defaults to zero when omitted.
                </td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>if</code></td>
                <td class="px-4 py-2 align-top">Specifies conditions for rule firing.</td>
                <td class="px-4 py-2 align-top">
                  May be a single expression string or a structured logical mapping.
                </td>
                <td class="px-4 py-2 align-top">
                  May be omitted. A rule without conditions always matches.
                </td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>let</code></td>
                <td class="px-4 py-2 align-top">Defines helper values for use in conditions and actions.</td>
                <td class="px-4 py-2 align-top">Mapping from variable names to expressions.</td>
                <td class="px-4 py-2 align-top">
                  Variables cannot reference themselves directly.
                </td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>then</code></td>
                <td class="px-4 py-2 align-top">Describes which paths to write when the rule fires.</td>
                <td class="px-4 py-2 align-top">Mapping from target paths to expressions.</td>
                <td class="px-4 py-2 align-top">
                  Required for rules that are expected to change facts.
                </td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>reason</code></td>
                <td class="px-4 py-2 align-top">
                  Explanation text used in monitoring and justification.
                </td>
                <td class="px-4 py-2 align-top">Text value.</td>
                <td class="px-4 py-2 align-top">Strongly recommended for explainability.</td>
              </tr>
              <tr>
                <td class="px-4 py-2 align-top"><code>stop</code></td>
                <td class="px-4 py-2 align-top">
                  Indicates whether engine evaluation should stop after this rule fires.
                </td>
                <td class="px-4 py-2 align-top">Boolean value.</td>
                <td class="px-4 py-2 align-top">
                  Use sparingly when early stopping is clearly required.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- FACTS STRUCTURE -->
      <section id="facts-structure" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">8. Facts structure</h2>
        <p>
          Facts represent the input data that rules operate on. They are structured as nested mappings
          of keys to values. The SESL engine treats the top level of the facts mapping as the main
          namespace for rule paths.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.1 Facts inside a model file</h3>
        <p>
          Within a model file, the <code>facts</code> section is a list of scenarios. Each scenario has
          its own copy of the facts mapping.
        </p>
        <pre><code>facts:
  - name: "Young customer"
    customer:
      age: 22
      country: "United Kingdom"
    result: {}

  - name: "Senior customer"
    customer:
      age: 70
      country: "United Kingdom"
    result: {}</code></pre>

        <p>Common patterns:</p>
        <ul>
          <li>
            Use nested keys to group related information, such as all customer data under
            <code>customer</code>.
          </li>
          <li>
            Include an initial <code>result</code> mapping to hold outputs from rules. The engine will
            create one if it is not present, but adding it explicitly is clearer.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.2 Engine metadata in facts</h3>
        <p>
          When the engine runs, it stores its own metadata under a reserved top level key named
          <code>_sesl</code>. This metadata includes:
        </p>
        <ul>
          <li>A snapshot of the original facts.</li>
          <li>Support information for truth maintenance.</li>
          <li>Monitoring information and execution metrics.</li>
          <li>Configuration information derived from the engine configuration object.</li>
        </ul>
        <p>
          Rules should not write to fields under <code>_sesl</code>. That namespace is reserved for
          engine data.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">8.3 How rules consume facts</h3>
        <p>Rules access facts using dot separated paths, for example:</p>
        <ul>
          <li><code>customer.age</code></li>
          <li><code>customer.country</code></li>
          <li><code>result.score</code></li>
        </ul>
        <p>
          The engine resolves these paths against the current facts mapping. In strict path mode, a
          missing intermediate segment leads to a clear error. This protects you from subtle mistakes
          such as misspelt keys.
        </p>
      </section>

      <!-- ENGINE -->
      <section id="engine" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">9. How the SESL engine works</h2>
        <p>
          The SESL engine is a forward chaining inference engine implemented in Python. It loads rules
          and facts, validates them, and then fires rules until no more changes occur or a limit is
          reached.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">9.1 High level architecture</h3>
        <ol>
          <li>
            <strong>Model loading.</strong> The <code>load_model_from_yaml</code> function parses the
            structured text model and returns compiled rules together with fact scenarios.
          </li>
          <li>
            <strong>Preflight validation.</strong> The <code>preflight_validate_model</code> function
            performs inexpensive checks such as duplicate rule names and obvious path issues.
          </li>
          <li>
            <strong>Dependency ordering.</strong> Rules are sorted by priority and by the dependencies
            between read and written sections.
          </li>
          <li>
            <strong>Forward chaining.</strong> The <code>forward_chain</code> function repeatedly evaluates
            rule conditions and applies actions.
          </li>
          <li>
            <strong>Explainability and metrics.</strong> The <code>Monitor</code> class records events,
            actions, and metrics for later inspection.
          </li>
        </ol>

        <h3 class="text-2xl font-semibold mt-6 mb-3">9.2 Lifecycle of a single run</h3>
        <ol>
          <li>
            The engine takes a list of compiled rules and a facts mapping. It also optionally receives
            an engine configuration and a monitor instance.
          </li>
          <li>
            It makes a snapshot of the starting facts for later explanations and truth maintenance.
          </li>
          <li>
            It attaches configuration and rule metadata under the <code>_sesl</code> key of the facts.
          </li>
          <li>
            It enters a loop that runs for at most a fixed number of iterations (for example twenty).
          </li>
          <li>
            In each iteration, the engine evaluates each rule in the sorted order:
            <ul>
              <li>It prepares a <code>_let</code> mapping and computes each helper expression.</li>
              <li>It evaluates the rule conditions using the current facts and helper values.</li>
              <li>
                If the conditions are satisfied, it applies actions by writing to target paths in the
                facts mapping.
              </li>
              <li>It records monitoring events, including rule evaluation and firing.</li>
            </ul>
          </li>
          <li>
            At the end of each iteration, it compares a fingerprint of the user visible facts. If the
            fingerprint has not changed since the previous iteration, the engine stops because the state
            is stable.
          </li>
        </ol>

        <h3 class="text-2xl font-semibold mt-6 mb-3">9.3 Walkthrough example</h3>
        <p>Consider the following very small model:</p>
        <pre><code>model: "Simple flag demo"

rules:
  - rule: "Flag high amount"
    if: "transaction.amount &gt; 1000"
    then:
      result.flagged: true
      result.flag_reason: "High transaction amount"
    reason: "Highlight unusually large transactions"

facts:
  - name: "Transaction demo"
    transaction:
      amount: 1500
    result: {}</code></pre>

        <p>Processing steps for this example:</p>
        <ol>
          <li>The engine loads one rule and one scenario.</li>
          <li>It starts the first iteration and evaluates the rule.</li>
          <li>
            The condition <code>"transaction.amount &gt; 1000"</code> is true, because the amount is
            one thousand five hundred.
          </li>
          <li>The engine writes two values into the <code>result</code> mapping.</li>
          <li>It records that the rule fired and why.</li>
          <li>
            At the end of the iteration, the fingerprint of the facts differs from the starting
            fingerprint, so the engine checks another iteration.
          </li>
          <li>In the next iteration, evaluating the same rule does not change any value.</li>
          <li>The fingerprint now matches the previous one, so the engine stops.</li>
        </ol>

        <p>The final result might look like this:</p>
        <pre><code>result: {
  "flagged": true,
  "flag_reason": "High transaction amount",
  "monitor": [...],
  "monitor_blocks": [...],
  "monitor_theme": "colour"
}</code></pre>
      </section>

      <!-- OUTPUT -->
      <section id="output" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">10. Output of run commands</h2>
        <p>
          This section describes the main parts of the engine output when you call the
          <code>forward_chain</code> function. The engine mutates the facts mapping in place and attaches
          several helpful structures.
        </p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">10.1 Result section</h3>
        <p>
          The most important part for application logic is the <code>result</code> mapping. This is where
          your rules usually write decisions and scores.
        </p>
        <pre><code>result: {
  "decision": "approve",
  "decision_reason": "Very high income",
  "score": 78
}</code></pre>
        <p>Each field in the result mapping is entirely defined by your model. Common patterns include:</p>
        <ul>
          <li><code>decision</code>: approve, decline, refer, and similar outcomes.</li>
          <li><code>decision_reason</code>: free text explanation of the decision.</li>
          <li><code>score</code>: numeric score or rating.</li>
          <li><code>flags</code>: sub-mapping with Boolean flags describing conditions.</li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">10.2 Monitor fields</h3>
        <p>
          When you pass a monitor instance to the engine, the engine attaches monitoring information
          under both the <code>_sesl</code> key and the <code>result</code> mapping for convenience.
        </p>
        <pre><code>result: {
  "decision": "approve",
  "monitor": [
    {"step": 1, "message": "--- Iteration 1 ---"},
    {"step": 2, "message": "Evaluating Set high income flag", "details": {...}},
    {"step": 3, "message": "Rule Set high income flag sets result.high_income = True"},
    {"step": 4, "message": "Rule Set high income flag FIRED", "details": {...}}
  ],
  "monitor_blocks": [
    "ðŸŸ¢ Rule Set high income flag\n   â”œâ”€ Evaluation:\n   â”‚     matched: True\n   â”‚     ...",
    "ðŸŸ¢ Rule Recommend approval for very high income\n   ..."
  ],
  "monitor_theme": "colour"
}</code></pre>

        <p>Field meanings:</p>
        <ul>
          <li>
            <strong>monitor</strong>: a list of raw monitor events, in chronological order. Each event has
            a numeric step and a message, and may have details.
          </li>
          <li>
            <strong>monitor_blocks</strong>: human readable multi-line blocks summarising each rule, its
            evaluation, and actions.
          </li>
          <li>
            <strong>monitor_theme</strong>: a hint string used by user interfaces to pick a presentation
            style.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">10.3 Metrics and configuration</h3>
        <p>
          The engine attaches metrics and configuration details under the <code>_sesl</code> key on the
          facts mapping. For example:
        </p>
        <pre><code>_sesl:
  metrics:
    iterations: 2
    rules_evaluated: 4
    rules_fired: 2
    elapsed_ms: 3.712
    convergence_fingerprint: "&lt;hash string&gt;"
  _config:
    strict_operands: true
    strict_paths: true
    auto_create_paths: false
    let_missing: "error"
    dependency_sort: true
    strict_actions: false
    error_style: "fancy"
    conflict_policy: "warn"
    logger: "NullLogger"</code></pre>

        <p>These fields help with tuning and diagnostics:</p>
        <ul>
          <li><strong>iterations</strong>: number of forward chaining cycles completed.</li>
          <li><strong>rules_evaluated</strong>: how many rule evaluations were performed.</li>
          <li><strong>rules_fired</strong>: how many times rules actually changed facts.</li>
          <li><strong>elapsed_ms</strong>: total execution time in milliseconds.</li>
          <li>
            <strong>convergence_fingerprint</strong>: hash of user visible facts used to detect stable
            state.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">10.4 Truth maintenance support</h3>
        <p>
          SESL collects support information for paths that rules write. This support information is stored
          under <code>_sesl.support</code> and <code>_sesl.support_detail</code> and can be used to
          explain why a fact has a particular value.
        </p>
        <pre><code>_sesl:
  support:
    "result.decision": ["Approve on high income"]
  support_detail:
    "result.decision":
      "Approve on high income":
        reason: "Applicant has very high income"
        priority: 10</code></pre>

        <p>
          The helper function <code>explain_fact(facts, "result.decision")</code> returns a structured
          justification chain for a given path.
        </p>
      </section>

      <!-- BUSINESS EXAMPLES -->
      <section id="examples" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">11. Examples: SESL in business contexts</h2>
        <p>
          This section presents five business examples that show SESL in realistic situations. Each
          example consists of a scenario description, a model fragment, sample input data, and a short
          explanation of the engine output.
        </p>

        <!-- EXAMPLE 1 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">11.1 Insurance risk assessment</h3>
        <p><strong>Scenario.</strong> An insurance company wants to flag high risk motor policies.</p>
        <pre><code>model: "Motor risk flags"

rules:
  - rule: "Flag young driver"
    if: "policy.driver_age &lt; 25"
    then:
      result.risk_flags.young_driver: true
    reason: "Driver is younger than twenty five years"

  - rule: "Flag powerful car"
    if: "policy.engine_power_kw &gt; 150"
    then:
      result.risk_flags.powerful_car: true
    reason: "Vehicle has high engine power"

  - rule: "Set overall risk band"
    let:
      has_any_flag: "result.risk_flags.young_driver or result.risk_flags.powerful_car"
    if: "has_any_flag"
    then:
      result.risk_band: "high"
    reason: "At least one high risk flag is present"

facts:
  - name: "Example policy"
    policy:
      driver_age: 22
      engine_power_kw: 160
    result: {}</code></pre>

        <p><strong>Execution.</strong></p>
        <pre><code>rules, scenarios = load_model_from_yaml(open("motor.sesl.yaml").read())
name, facts = scenarios[0]
monitor = Monitor()
forward_chain(rules, facts, monitor=monitor)
print(facts["result"])</code></pre>

        <p><strong>Interpretation.</strong></p>
        <ul>
          <li>The first rule sets <code>result.risk_flags.young_driver</code> to true.</li>
          <li>The second rule sets <code>result.risk_flags.powerful_car</code> to true.</li>
          <li>
            The third rule sees that at least one flag is set and assigns the overall
            <code>result.risk_band</code> to <code>"high"</code>.
          </li>
          <li>The explanation data shows clearly which flags led to the high risk band.</li>
        </ul>

        <!-- EXAMPLE 2 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">11.2 Banking credit scoring</h3>
        <p><strong>Scenario.</strong> A bank wants to compute a simple credit score.</p>
        <pre><code>model: "Credit score demo"

const:
  income_threshold: 30000
  low_debt_ratio: 0.3

rules:
  - rule: "Base score"
    then:
      result.score: 50
    reason: "Starting score"

  - rule: "Increase score for high income"
    if: "applicant.income &gt;= const.income_threshold"
    then:
      result.score: "result.score + 20"
    reason: "Stable income"

  - rule: "Decrease score for high debt ratio"
    let:
      debt_ratio: "applicant.total_debt / max(applicant.income, 1)"
    if: "debt_ratio &gt; 0.5"
    then:
      result.score: "result.score - 30"
    reason: "High debt compared with income"

facts:
  - name: "Applicant example"
    applicant:
      income: 40000
      total_debt: 15000
    result:
      score: 0</code></pre>

        <p><strong>Execution and outcome.</strong></p>
        <ul>
          <li>The base score rule sets the score to fifty.</li>
          <li>The high income rule adds twenty, bringing the score to seventy.</li>
          <li>The debt ratio is fifteen thousand divided by forty thousand, which is zero point three seven five.</li>
          <li>The debt ratio rule does not fire because the ratio is not greater than zero point five.</li>
          <li>The final score is seventy.</li>
        </ul>

        <!-- EXAMPLE 3 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">11.3 Retail pricing and discounts</h3>
        <p><strong>Scenario.</strong> A retailer wants to apply volume discounts.</p>
        <pre><code>model: "Volume discount"

rules:
  - rule: "Ten percent discount for ten or more items"
    if: "basket.quantity &gt;= 10"
    then:
      result.discount_rate: 0.10
    reason: "Volume discount for ten or more items"

  - rule: "Fifteen percent discount for twenty or more items"
    priority: 20
    if: "basket.quantity &gt;= 20"
    then:
      result.discount_rate: 0.15
    reason: "Higher volume discount for twenty or more items"

  - rule: "Compute total price"
    let:
      discounted_price_per_unit: "basket.unit_price * (1 - result.discount_rate)"
    then:
      result.total_price: "basket.quantity * discounted_price_per_unit"
    reason: "Apply discount rate to quantity and unit price"

facts:
  - name: "Basket example"
    basket:
      quantity: 22
      unit_price: 5.00
    result:
      discount_rate: 0.0</code></pre>

        <p><strong>Interpretation.</strong></p>
        <ul>
          <li>
            Both discount rules match, but the higher priority rule that sets fifteen percent discount
            takes ownership of <code>result.discount_rate</code>.
          </li>
          <li>
            The compute total price rule uses the final discount rate and writes the total price. With a
            quantity of twenty two and a unit price of five, the discounted price per unit is four point
            two five, giving a total price of ninety three point five.
          </li>
        </ul>

        <!-- EXAMPLE 4 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">11.4 Supply chain routing</h3>
        <p><strong>Scenario.</strong> A logistics team wants to pick a warehouse to ship from.</p>
        <pre><code>model: "Warehouse selection"

rules:
  - rule: "Prefer local warehouse"
    if:
      all:
        - "order.destination_country == 'United Kingdom'"
        - "stock.local_available &gt;= order.quantity"
    then:
      result.source_warehouse: "local"
    reason: "Destination is local and local stock is sufficient"

  - rule: "Fallback to regional warehouse"
    if: "result.source_warehouse is None and stock.regional_available &gt;= order.quantity"
    then:
      result.source_warehouse: "regional"
    reason: "Local warehouse cannot fulfil the order"

facts:
  - name: "Order example"
    order:
      destination_country: "United Kingdom"
      quantity: 50
    stock:
      local_available: 40
      regional_available: 100
    result:
      source_warehouse: null</code></pre>

        <p><strong>Outcome.</strong></p>
        <ul>
          <li>The local warehouse rule does not fire because local stock is only forty.</li>
          <li>
            The regional warehouse rule fires and sets <code>result.source_warehouse</code> to
            <code>"regional"</code>.
          </li>
          <li>
            Explainability data records that the fallback rule provided the value, together with its
            reason text.
          </li>
        </ul>

        <!-- EXAMPLE 5 -->
        <h3 class="text-2xl font-semibold mt-8 mb-3">11.5 Compliance checking</h3>
        <p><strong>Scenario.</strong> A compliance team wants to check whether a transaction breaches simple policy rules.</p>
        <pre><code>model: "Policy compliance"

const:
  maximum_single_transaction: 10000
  restricted_country_list: ["Country X", "Country Y"]

rules:
  - rule: "Flag large transaction"
    if: "transaction.amount &gt; const.maximum_single_transaction"
    then:
      result.policy_flags.large_transaction: true
    reason: "Amount is greater than policy limit"

  - rule: "Flag restricted destination country"
    if: "transaction.country in const.restricted_country_list"
    then:
      result.policy_flags.restricted_country: true
    reason: "Destination country is on the restricted list"

  - rule: "Set compliance outcome"
    let:
      any_flag: "result.policy_flags.large_transaction or result.policy_flags.restricted_country"
    if: "any_flag"
    then:
      result.compliance_outcome: "review_required"
    reason: "At least one policy flag is present"

facts:
  - name: "Payment example"
    transaction:
      amount: 12000
      country: "Country X"
    result:
      policy_flags: {}</code></pre>

        <p><strong>Outcome.</strong></p>
        <ul>
          <li>The large transaction rule fires because the amount is greater than ten thousand.</li>
          <li>The restricted country rule also fires because the destination country is in the list.</li>
          <li>
            The final outcome is <code>result.compliance_outcome</code> set to
            <code>"review_required"</code>.
          </li>
          <li>
            The monitor blocks show exactly which conditions and values led to this outcome, which helps
            when reviewing cases.
          </li>
        </ul>
      </section>

      <!-- BEST PRACTICES -->
      <section id="best-practices" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">12. Best practices and common pitfalls</h2>

        <h3 class="text-2xl font-semibold mt-6 mb-3">12.1 Organising models, rules, and facts</h3>
        <ul>
          <li>
            Use one SESL model per coherent decision area, such as one model for eligibility and another
            for pricing.
          </li>
          <li>
            Group related rules near each other and use descriptive rule names that start with a verb,
            such as â€œSet tierâ€ or â€œFlag high riskâ€.
          </li>
          <li>
            Keep example fact scenarios small and focused. Each scenario should illustrate one main path
            through the rules.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">12.2 Naming conventions</h3>
        <ul>
          <li>
            Use lower case and underscores for keys, such as <code>total_debt</code> rather than
            <code>TotalDebt</code>.
          </li>
          <li>
            Use consistent namespaces such as <code>applicant</code>, <code>customer</code>,
            <code>transaction</code>, and <code>result</code>.
          </li>
          <li>
            Use the <code>result</code> namespace only for outputs from rules, not for inputs. This keeps
            it clear which fields are derived.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">12.3 Performance considerations</h3>
        <ul>
          <li>
            Avoid unnecessary complexity in conditions. If a condition becomes very long, consider
            computing parts of it in the <code>let</code> block.
          </li>
          <li>
            Use priorities to avoid repeatedly overwriting the same path from many rules.
          </li>
          <li>
            Monitor iteration counts and rule fire counts. Unexpectedly high values may indicate cycles
            or rules that constantly flip values back and forth.
          </li>
        </ul>

        <h3 class="text-2xl font-semibold mt-6 mb-3">12.4 Common pitfalls</h3>
        <ul>
          <li>
            <strong>Missing parent paths.</strong> When strict path mode is enabled and automatic path
            creation is disabled, attempting to write to <code>result.score</code> without having a
            <code>result</code> mapping leads to a helpful error. Seed <code>result: {}</code> in facts.
          </li>
          <li>
            <strong>Unquoted string literals.</strong> In strict operand mode, text values must be quoted.
            Writing <code>then: result.status: approved</code> without quotes will cause a resolution
            error.
          </li>
          <li>
            <strong>Self-referential let expressions.</strong> A helper variable cannot refer to itself.
            This is caught at compile time to prevent confusing behaviour.
          </li>
          <li>
            <strong>Conflicting writes.</strong> Multiple rules that write to the same path at the same
            priority may conflict. The engine can warn or raise an error depending on configuration.
          </li>
        </ul>
      </section>

      <!-- CONCLUSION -->
      <section id="conclusion" class="mt-12 scroll-mt-24">
        <h2 class="text-3xl font-semibold mb-4">13. Conclusion and next steps</h2>
        <p>
          SESL provides a focused, transparent way to express decision logic as rules over structured
          data. You have seen how models are structured, how rules and facts interact, how the engine
          evaluates conditions and actions, and how to interpret the output and explanation data.
        </p>
        <p>Possible next steps include:</p>
        <ul>
          <li>Creating your own small model for a decision in your organisation.</li>
          <li>
            Adding more example scenarios to test edge cases and ensure that rules behave as expected.
          </li>
          <li>
            Integrating SESL into an application by building a wrapper that prepares facts and consumes
            the result and explanation structures.
          </li>
          <li>
            Exploring the monitor and truth maintenance data to build user interfaces that explain
            decisions.
          </li>
        </ul>
        <p>
          With careful model design and the engine features described in this guide, SESL can act as a
          reliable and understandable decision layer in many different domains.
        </p>
      </section>
    </article>
  </div>
</main>

<!-- FOOTER (copied style from pricing page) -->
<footer class="border-t border-slate-300 dark:border-slate-800 py-16 px-4">
  <div class="max-w-7xl mx-auto grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-10">

    <div>
      <h4 class="font-semibold mb-3">Product</h4>
      <ul class="space-y-2 text-sm text-slate-600 dark:text-slate-400">
        <li><a href="product.html" class="hover:text-brand-600">Overview</a></li>
        <li><a href="product.html#features" class="hover:text-brand-600">Features</a></li>
        <li><a href="#demo" class="hover:text-brand-600">Demo</a></li>
      </ul>
    </div>

    <div>
      <h4 class="font-semibold mb-3">Solutions</h4>
      <ul class="space-y-2 text-sm text-slate-600 dark:text-slate-400">
        <li><a href="solutions.html" class="hover:text-brand-600">Use Cases</a></li>
        <li><a href="solutions.html#compliance" class="hover:text-brand-600">Compliance</a></li>
        <li><a href="solutions.html#enterprise" class="hover:text-brand-600">Enterprise</a></li>
        <li><a href="solutions.html#automation" class="hover:text-brand-600">Process Automation</a></li>
      </ul>
    </div>

    <div>
      <h4 class="font-semibold mb-3">Resources</h4>
      <ul class="space-y-2 text-sm text-slate-600 dark:text-slate-400">
        <li><a href="resources.html" class="hover:text-brand-600">Documentation</a></li>
        <li><a href="https://github.com/YOUR_REPO/releases" class="hover:text-brand-600">Download</a></li>
        <li><a href="resources.html#connect" class="hover:text-brand-600">LLM Server</a></li>
        <li><a href="resources.html#examples" class="hover:text-brand-600">Examples</a></li>
      </ul>
    </div>

    <div>
      <h4 class="font-semibold mb-3">Company</h4>
      <ul class="space-y-2 text-sm text-slate-600 dark:text-slate-400">
        <li><a href="about.html" class="hover:text-brand-600">About SESL</a></li>
        <li><a href="about.html#mission" class="hover:text-brand-600">Mission</a></li>
        <li><a href="about.html#contact" class="hover:text-brand-600">Contact</a></li>
      </ul>
    </div>

  </div>

  <div class="max-w-7xl mx-auto mt-12 pt-8 border-t border-slate-300 dark:border-slate-800 flex flex-col sm:flex-row justify-between items-center gap-4">
    <div class="flex items-center gap-3">
      <img src="SESL Logo.png" class="h-7 block dark:hidden" alt="SESL logo light" />
      <img src="SESL Logo Dark.png" class="h-7 hidden dark:block" alt="SESL logo dark" />
      <span class="text-sm text-slate-600 dark:text-slate-400">Simple Expert System Language</span>
    </div>

    <div class="flex gap-4">
      <a href="#" class="text-slate-600 hover:text-brand-600 dark:text-slate-400">Twitter</a>
      <a href="#" class="text-slate-600 hover:text-brand-600 dark:text-slate-400">LinkedIn</a>
    </div>
  </div>

  <div class="text-center mt-6 text-sm text-slate-500 dark:text-slate-500">
    Â© <span id="year"></span> Oblongix. All rights reserved.
  </div>
</footer>

<script>
  // Theme toggle
  const btn = document.getElementById("themeToggle");
  btn.addEventListener("click", () => {
    const isDark = document.documentElement.classList.toggle("dark");
    localStorage.setItem("theme", isDark ? "dark" : "light");
    btn.textContent = isDark ? "â˜€ï¸" : "ðŸŒ™";
  });
  btn.textContent = document.documentElement.classList.contains("dark") ? "â˜€ï¸" : "ðŸŒ™";

  // Mobile menu
  const mobileBtn = document.getElementById("mobileMenuBtn");
  const mobileMenu = document.getElementById("mobileMenu");
  mobileBtn.addEventListener("click", () => {
    mobileMenu.classList.toggle("hidden");
  });

  // Year
  document.getElementById("year").textContent = new Date().getFullYear();
</script>

</body>
</html>
